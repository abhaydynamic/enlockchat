<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enlock Chat - Secure End-to-End Encrypted Messaging</title>
    <meta name="description" content="Enlock Chat - Privacy-first messaging with end-to-end encryption, voice messages, file sharing, and real-time communication">
    <meta name="keywords" content="secure chat, encrypted messaging, privacy, end-to-end encryption, voice messages">
    <meta name="author" content="Enlock Chat">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Enlock Chat">
    <meta name="msapplication-TileColor" content="#667eea">
    
    <!-- Favicon and Icons -->
    <link rel="icon" type="image/svg+xml" href="/static/logo.svg">
    <link rel="icon" type="image/png" href="/static/logo.png">
    <link rel="apple-touch-icon" href="/static/logo.png">
    
    <!-- Manifest -->
    <link rel="manifest" href="/static/manifest.json">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        :root {
            /* Light theme colors */
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --bg-tertiary: #f1f5f9;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --text-muted: #94a3b8;
            --border-color: #e2e8f0;
            --border-light: #f1f5f9;
            --shadow-light: rgba(0, 0, 0, 0.1);
            --shadow-medium: rgba(0, 0, 0, 0.15);
            --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --glass-bg: rgba(255, 255, 255, 0.95);
            --glass-border: rgba(255, 255, 255, 0.2);
            --chat-other-bg: #f1f5f9;
            --chat-other-text: #334155;
            --input-bg: #ffffff;
            --hover-bg: #f8fafc;
            --modal-bg: rgba(0, 0, 0, 0.5);
            --accent-color: #667eea;
            --accent-shadow: rgba(102, 126, 234, 0.1);
            --accent-bg: #eff6ff;
            --accent-border: rgba(102, 126, 234, 0.4);
            --success-color: #10b981;
            --success-hover: #059669;
            --bg-hover: #f8fafc;
        }
        
        [data-theme="dark"] {
            /* Dark theme colors */
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --border-color: #374151;
            --border-light: #475569;
            --shadow-light: rgba(0, 0, 0, 0.3);
            --shadow-medium: rgba(0, 0, 0, 0.4);
            --gradient-primary: linear-gradient(135deg, #4338ca 0%, #7c3aed 100%);
            --glass-bg: rgba(15, 23, 42, 0.95);
            --glass-border: rgba(255, 255, 255, 0.1);
            --chat-other-bg: #374151;
            --chat-other-text: #e2e8f0;
            --input-bg: #1e293b;
            --hover-bg: #334155;
            --modal-bg: rgba(0, 0, 0, 0.7);
            --accent-color: #4338ca;
            --accent-shadow: rgba(67, 56, 202, 0.2);
            --accent-bg: rgba(67, 56, 202, 0.1);
            --accent-border: rgba(67, 56, 202, 0.3);
            --success-color: #10b981;
            --success-hover: #059669;
            --bg-hover: #334155;
        }
        
        * {
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        
        body { 
            font-family: 'Inter', sans-serif; 
            background: var(--gradient-primary);
            min-height: 100vh;
            color: var(--text-primary);
        }
        
        .glass-effect {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
        }
        
        .chat-sidebar {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border-right: 1px solid var(--border-color);
        }
        
        .chat-main {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
        }
        
        .message-bubble {
            max-width: 75%;
            word-wrap: break-word;
        }
        
        .message-bubble p {
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
        }
        
        .my-message {
            background: var(--gradient-primary);
            color: white;
        }
        
        .other-message {
            background: var(--chat-other-bg);
            color: var(--chat-other-text);
            border: 1px solid var(--border-color);
        }
        
        /* Link Preview Styles */
        .link-preview {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            margin-top: 8px;
            background: var(--bg-secondary);
            transition: all 0.3s ease;
            cursor: pointer;
            max-width: 400px;
        }
        
        .link-preview:hover {
            border-color: var(--text-secondary);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px var(--shadow-light);
        }
        
        .link-preview-image {
            width: 100%;
            height: 160px;
            object-fit: cover;
            background: var(--bg-tertiary);
        }
        
        .link-preview-content {
            padding: 12px;
        }
        
        .link-preview-title {
            font-weight: 600;
            color: var(--text-primary);
            margin: 0 0 6px 0;
            font-size: 0.9rem;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .link-preview-description {
            color: var(--text-secondary);
            font-size: 0.85rem;
            line-height: 1.4;
            margin: 0 0 8px 0;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .link-preview-domain {
            color: var(--text-muted);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .link-preview-favicon {
            width: 16px;
            height: 16px;
            border-radius: 2px;
        }
        
        .link-preview-loading {
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-muted);
            font-size: 0.85rem;
        }
        
        .link-preview-error {
            padding: 12px;
            color: var(--text-muted);
            font-size: 0.85rem;
            font-style: italic;
        }
        
        @keyframes linkPreviewFadeIn {
            from { 
                opacity: 0; 
                transform: translateY(10px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }
        
        .link-preview {
            animation: linkPreviewFadeIn 0.3s ease-out;
        }
        
        /* Message Link Styles */
        .message-link {
            color: inherit;
            text-decoration: underline;
            opacity: 0.9;
            transition: opacity 0.2s ease;
        }
        
        .message-link:hover {
            opacity: 1;
            text-decoration: underline;
        }
        
        .my-message .message-link {
            color: rgba(255, 255, 255, 0.9);
        }
        
        .other-message .message-link {
            color: var(--text-primary);
        }
        
        .online-indicator {
            width: 8px;
            height: 8px;
            background: var(--success-color);
            border-radius: 50%;
            position: absolute;
            bottom: 0;
            right: 0;
            border: 2px solid var(--bg-primary);
        }
        
        /* Profile Avatar Styles */
        .profile-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            line-height: 1;
            font-weight: 600;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            user-select: none;
            flex-shrink: 0;
        }
        
        .profile-avatar-sm {
            width: 32px;
            height: 32px;
            font-size: 14px;
        }
        
        .profile-avatar-lg {
            width: 48px;
            height: 48px;
            font-size: 18px;
        }
        
        .search-input:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px var(--accent-shadow);
        }
        
        /* Update general styles for dark mode */
        input, textarea, select {
            background: var(--input-bg);
            color: var(--text-primary);
            border-color: var(--border-color);
        }
        
        input:focus, textarea:focus, select:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px var(--accent-shadow);
        }
        
        .modal-overlay {
            background: var(--modal-bg);
        }
        
        .modal-content {
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        /* Dark mode for specific elements */
        .border-gray-200 {
            border-color: var(--border-color) !important;
        }
        
        .border-gray-300 {
            border-color: var(--border-color) !important;
        }
        
        .bg-gray-50 {
            background-color: var(--hover-bg) !important;
        }
        
        .bg-gray-100 {
            background-color: var(--bg-tertiary) !important;
        }
        
        .text-gray-900 {
            color: var(--text-primary) !important;
        }
        
        .text-gray-700 {
            color: var(--text-primary) !important;
        }
        
        .text-gray-500 {
            color: var(--text-secondary) !important;
        }
        
        .text-gray-600 {
            color: var(--text-secondary) !important;
        }
        
        .text-gray-400 {
            color: var(--text-muted) !important;
        }
        
        .bg-white {
            background-color: var(--bg-primary) !important;
        }
        
        .bg-green-50 {
            background-color: var(--bg-secondary) !important;
        }
        
        /* Chat-specific elements */
        .chat-sidebar {
            background: var(--glass-bg) !important;
            border-color: var(--border-color) !important;
        }
        
        .chat-main {
            background: var(--glass-bg) !important;
        }
        
        #chat-header {
            background: var(--bg-primary) !important;
            border-color: var(--border-color) !important;
        }
        
        #message-input-container {
            background: var(--bg-primary) !important;
            border-color: var(--border-color) !important;
        }
        
        .search-input {
            background: var(--input-bg) !important;
            color: var(--text-primary) !important;
            border-color: var(--border-color) !important;
        }
        
        .chat-list-item:hover {
            background: var(--hover-bg) !important;
        }
        
        /* Dark mode hover styles */
        .hover\\:bg-gray-50:hover {
            background-color: var(--hover-bg) !important;
        }
        
        .hover\\:bg-gray-100:hover {
            background-color: var(--bg-tertiary) !important;
        }
        
        .hover\\:bg-gray-200:hover {
            background-color: var(--border-color) !important;
        }
        
        .hover\\:text-gray-700:hover {
            color: var(--text-primary) !important;
        }
        
        /* Button styles for dark mode */
        button {
            color: var(--text-secondary);
        }
        
        button:hover {
            color: var(--text-primary);
        }
        
        /* Search and input focus styles */
        .search-input:focus {
            border-color: var(--accent-color) !important;
            box-shadow: 0 0 0 3px var(--accent-shadow) !important;
        }
        
        .btn-primary {
            background: var(--gradient-primary);
            transition: all 0.3s ease;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }
        
        /* Dark Mode Toggle */
        .dark-mode-toggle {
            padding: 8px;
            border-radius: 8px;
            background: var(--hover-bg);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .dark-mode-toggle:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            transform: scale(1.05);
        }
        
        .dark-mode-toggle .dark-icon,
        .dark-mode-toggle .light-icon {
            transition: all 0.3s ease;
            position: absolute;
        }
        
        [data-theme="dark"] .dark-mode-toggle .dark-icon {
            opacity: 0;
            transform: rotate(180deg);
        }
        
        [data-theme="dark"] .dark-mode-toggle .light-icon {
            opacity: 1;
            transform: rotate(0deg);
        }
        
        [data-theme="light"] .dark-mode-toggle .light-icon,
        :root .dark-mode-toggle .light-icon {
            opacity: 0;
            transform: rotate(180deg);
        }
        
        [data-theme="light"] .dark-mode-toggle .dark-icon,
        :root .dark-mode-toggle .dark-icon {
            opacity: 1;
            transform: rotate(0deg);
        }
        
        .chat-list-item:hover {
            background: rgba(102, 126, 234, 0.05);
        }
        
        .encryption-badge {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            font-size: 0.75rem;
            padding: 2px 8px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        
        @keyframes progressPulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        #loading-overlay .glass-effect {
            animation: fadeIn 0.3s ease-out;
        }
        
        #loading-overlay .animate-pulse {
            animation: progressPulse 2s ease-in-out infinite;
        }
        
        .date-separator {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-weight: 500;
            padding: 4px 12px;
            border-radius: 12px;
            margin: 16px auto;
            text-align: center;
            width: fit-content;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(229, 231, 235, 0.8);
        }
        
        .message-container {
            position: relative;
            margin-bottom: 12px;
        }
        
        .message-actions {
            position: absolute;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 10;
        }
        
        .message-container:hover .message-actions {
            opacity: 1;
        }
        
        .message-container.my-message-container .message-actions {
            left: -40px;
        }
        
        .message-container.other-message-container .message-actions {
            right: -40px;
        }
        
        .reaction-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 8px var(--shadow-light);
        }
        
        .reaction-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px var(--shadow-medium);
        }
        
        .reaction-btn i {
            color: var(--text-secondary);
        }
        
        .emoji-picker {
            position: absolute;
            background: var(--bg-primary);
            border-radius: 24px;
            padding: 8px 12px;
            box-shadow: 0 8px 25px var(--shadow-medium);
            border: 1px solid var(--border-color);
            display: flex;
            gap: 4px;
            z-index: 20;
            animation: emojiPickerFadeIn 0.2s ease;
        }
        
        @keyframes emojiPickerFadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        
        .emoji-option {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s ease;
        }
        
        .emoji-option:hover {
            background: var(--hover-bg);
            transform: scale(1.2);
        }
        
        .message-reactions {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 6px;
            max-width: 300px;
        }
        
        .reaction-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 2px 8px;
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 32px;
            justify-content: center;
        }
        
        .reaction-item:hover {
            background: rgba(102, 126, 234, 0.1);
            border-color: rgba(102, 126, 234, 0.3);
        }
        
        .reaction-item.my-reaction {
            background: rgba(102, 126, 234, 0.15);
            border-color: var(--accent-border);
            color: var(--accent-color);
            font-weight: 500;
        }
        
        .reaction-count {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-muted);
        }
        
        .my-reaction .reaction-count {
            color: var(--accent-color);
        }
        
        .file-upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 8px;
            margin-right: 8px;
            transition: all 0.2s ease;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            background: rgba(102, 126, 234, 0.05);
        }
        
        .file-upload-area:hover {
            border-color: var(--accent-color);
            background: var(--accent-bg);
        }
        
        .file-upload-area.dragover {
            border-color: var(--accent-color);
            background: var(--accent-bg);
        }
        
        .media-message {
            max-width: 300px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .media-message img {
            width: 100%;
            height: auto;
            display: block;
            max-height: 400px;
            object-fit: cover;
        }
        
        .media-message video {
            width: 100%;
            height: auto;
            display: block;
            max-height: 400px;
        }
        
        .file-message {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            max-width: 300px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .file-message:hover {
            background: rgba(102, 126, 234, 0.05);
            border-color: #667eea;
        }
        
        .file-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: white;
            font-weight: bold;
        }
        
        .file-info {
            flex: 1;
            min-width: 0;
        }
        
        .file-name {
            font-weight: 500;
            color: #374151;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 14px;
        }
        
        .file-size {
            color: var(--text-secondary);
            font-size: 12px;
        }
        
        .upload-progress {
            background: rgba(102, 126, 234, 0.1);
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }
        
        .lightbox {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .lightbox.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .lightbox-content {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
        }
        
        .lightbox-close {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            cursor: pointer;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Message Menu Styles */
        .message-menu {
            position: fixed;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow-medium);
            z-index: 1000;
            min-width: 160px;
            overflow: hidden;
        }
        
        .menu-option {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 14px;
            color: var(--text-primary);
        }
        
        .menu-option:hover {
            background-color: var(--hover-bg);
        }
        
        .menu-option i {
            margin-right: 8px;
            width: 16px;
        }
        
        .deleted-message {
            opacity: 0.6;
            font-style: italic;
            background: var(--bg-tertiary) !important;
            color: var(--text-muted) !important;
        }
        
        .deleted-message.my-message {
            background: #ddd6fe !important;
        }
        
        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            /* Better mobile layout */
            body {
                overflow-x: hidden;
                width: 100vw;
                max-width: 100vw;
            }
            
            /* Mobile sidebar adjustments */
            .chat-sidebar {
                width: 100vw !important;
                max-width: 100vw !important;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                z-index: 40 !important;
                transition: transform 0.3s ease;
                height: 100vh !important;
                height: 100dvh !important; /* Dynamic viewport height for mobile */
                overflow-y: auto;
                border-right: none !important;
            }
            
            .chat-sidebar.hidden-mobile {
                transform: translateX(-100%);
            }
            
            /* Ensure sidebar content fills mobile screen */
            @media (max-width: 768px) {
                .chat-sidebar > * {
                    width: 100% !important;
                }
                
                /* Override any fixed widths in sidebar content */
                .chat-sidebar .flex,
                .chat-sidebar .block,
                .chat-sidebar .w-full {
                    width: 100% !important;
                    max-width: 100% !important;
                }
            }
            
            /* Mobile chat area */
            #chat-interface {
                flex-direction: column;
                width: 100vw !important;
                height: 100vh !important;
                height: 100dvh !important;
                overflow: hidden;
                position: relative;
            }
            
            .chat-main {
                width: 100%;
                margin-left: 0;
                height: 100vh;
                display: flex;
                flex-direction: column;
            }
            
            /* Mobile header improvements */
            #chat-header {
                padding: 12px 16px;
                min-height: 60px;
                flex-shrink: 0;
            }
            
            .mobile-back-btn {
                background: none;
                border: none;
                font-size: 1.25rem;
                color: #4b5563;
                margin-right: 12px;
                cursor: pointer;
                padding: 8px;
                border-radius: 8px;
                transition: background-color 0.2s;
                min-width: 40px;
                min-height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .mobile-back-btn:hover {
                background-color: #f3f4f6;
            }
            
            /* Messages container improvements */
            #messages-container {
                flex: 1;
                overflow-y: auto;
                padding: 12px;
                -webkit-overflow-scrolling: touch;
                scroll-behavior: smooth;
            }
            
            /* Mobile message improvements */
            .message-container {
                margin-bottom: 8px;
                max-width: 100%;
            }
            
            .message-bubble {
                max-width: 85%;
                min-width:max-content;
                font-size: 16px;
                padding: 12px 16px;
                line-height: 1.4;
                word-wrap: break-word;
                border-radius: 18px;
                position: relative;
            }
            
            /* Improve message bubble styling */
            .my-message {
                background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
                color: white;
                margin-left: auto;
                border-bottom-right-radius: 6px;
            }
            
            .other-message {
                background: #f1f3f4;
                color: #202124;
                margin-right: auto;
                border-bottom-left-radius: 6px;
            }
            
            /* Date separator improvements */
            .date-separator {
                text-align: center;
                margin: 16px 0;
                font-size: 12px;
                color: #666;
                background: #f0f0f0;
                padding: 6px 12px;
                border-radius: 12px;
                display: inline-block;
                width: auto;
                margin-left: auto;
                margin-right: auto;
            }
            
            /* Mobile message input improvements */
            #message-input-container {
                padding: 12px;
                background: white;
                border-top: 1px solid #e5e7eb;
                flex-shrink: 0;
                position: sticky;
                bottom: 0;
            }
            
            #message-form {
                gap: 8px;
                align-items: flex-end;
            }
            
            .file-upload-area {
                width: 44px;
                height: 44px;
                padding: 12px;
                border-radius: 22px;
                flex-shrink: 0;
            }
            
            #message-input {
                font-size: 16px;
                padding: 12px 16px;
                min-height: 44px;
                border-radius: 22px;
                border: 1px solid #e5e7eb;
                resize: none;
                outline: none;
                max-height: 150px;
                line-height: 1.4;
                font-family: inherit;
                overflow-y: auto;
                white-space: pre-wrap;
                word-wrap: break-word;
            }
            
            #message-input:focus {
                border-color: #007bff;
                box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
            }
            
            /* Scrollbar styling for message input */
            #message-input::-webkit-scrollbar {
                width: 6px;
            }
            
            #message-input::-webkit-scrollbar-thumb {
                background-color: rgba(0, 0, 0, 0.2);
                border-radius: 3px;
            }
            
            #message-input::-webkit-scrollbar-track {
                background-color: transparent;
            }
            
            .btn-primary {
                padding: 12px;
                min-width: 44px;
                min-height: 44px;
                border-radius: 22px;
                flex-shrink: 0;
            }
            
            /* Message timestamp improvements */
            .message-bubble p:last-child {
                font-size: 11px;
                opacity: 0.7;
                margin-top: 4px;
                margin-bottom: 0;
            }
            
            /* Reaction improvements */
            .message-reactions {
                margin-top: 4px;
                margin-bottom: 4px;
            }
            
            .reaction-item {
                min-width: 44px;
                min-height: 32px;
                padding: 6px 10px;
                margin: 2px;
                font-size: 14px;
            }
            
            /* Mobile emoji picker */
            .emoji-picker {
                position: fixed !important;
                bottom: 120px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                z-index: 1001;
                background: white;
                border: 1px solid #e5e7eb;
                border-radius: 20px;
                padding: 12px 16px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
                max-width: 280px;
                width: 90vw;
                display: flex !important;
                flex-wrap: nowrap;
                gap: 8px;
                justify-content: center;
                align-items: center;
            }
            
            .emoji-option {
                font-size: 22px;
                padding: 10px;
                min-width: 40px;
                min-height: 40px;
                border-radius: 12px;
                display: flex;
                align-items: center;
                justify-content: center;
                background: transparent;
                border: none;
                cursor: pointer;
                transition: all 0.2s ease;
            }
            
            .emoji-option:hover,
            .emoji-option:active {
                background: #f3f4f6;
                transform: scale(1.1);
            }
            
            /* File preview improvements */
            #file-preview {
                margin: 8px;
                padding: 16px;
                border-radius: 16px;
            }
            
            /* Media message improvements */
            .media-message {
                max-width: 280px;
                border-radius: 16px;
            }
            
            .media-message img,
            .media-message video {
                width: 100%;
                max-width: 280px;
                border-radius: 12px;
            }
            
            /* Search improvements */
            #search-results {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                z-index: 50;
                background: white;
                overflow-y: auto;
            }
            
            .search-result-item {
                padding: 16px;
                border-bottom: 1px solid #f3f4f6;
                min-height: 72px;
            }
            
            /* Message menu mobile */
            .message-menu {
                position: fixed !important;
                bottom: 120px !important;
                left: 50% !important;
                transform: translateX(-50%) !important;
                min-width: 240px;
                max-width: 300px;
                width: 80vw;
                border-radius: 16px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
                z-index: 1001;
                background: white;
                border: 1px solid #e5e7eb;
                overflow: hidden;
            }
            
            .menu-option {
                padding: 18px 24px;
                font-size: 16px;
                font-weight: 500;
                display: flex;
                align-items: center;
                gap: 12px;
                cursor: pointer;
                transition: all 0.2s ease;
                border-bottom: 1px solid #f3f4f6;
                min-height: 56px;
            }
            
            .menu-option:last-child {
                border-bottom: none;
            }
            
            .menu-option:hover,
            .menu-option:active {
                background-color: #f8f9fa;
            }
            
            .menu-option.delete-everyone {
                color: #dc2626;
            }
            
            .menu-option.delete-everyone:hover,
            .menu-option.delete-everyone:active {
                background-color: #fef2f2;
            }
            
            .menu-option i {
                font-size: 18px;
                width: 20px;
                display: flex;
                justify-content: center;
            }
            
            /* Better touch targets */
            .message-actions {
                padding: 8px;
            }
            
            .reaction-btn {
                width: 44px;
                height: 44px;
                font-size: 18px;
            }
            
            /* Mobile user options menu */
            .user-options-menu {
                position: fixed !important;
                top: auto !important;
                bottom: 120px !important;
                left: 50% !important;
                right: auto !important;
                transform: translateX(-50%) !important;
                min-width: 200px;
                border-radius: 16px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            }
            
            .user-option {
                padding: 16px 20px;
                font-size: 16px;
                min-height: 56px;
            }
            
            /* Mobile profile avatars */
            .profile-avatar {
                font-size: 16px;
                font-weight: 600;
            }
            
            .profile-avatar-lg {
                font-size: 20px;
            }
        }
        
        @media (max-width: 480px) {
            /* Extra small mobile adjustments */
            .message-bubble {
                max-width: 90%;
                font-size: 0.85rem;
                padding: 0.5rem 0.75rem;
            }
            
            .media-message {
                max-width: 250px;
            }
            
            .voice-message {
                max-width: 250px;
                padding: 0.75rem;
            }
            
            #message-input {
                font-size: 16px;
                padding: 0.625rem 0.875rem;
            }
            
            .file-upload-area {
                width: 40px;
                height: 40px;
                padding: 8px;
            }
            
            .btn-primary {
                padding: 0.625rem;
                min-width: 40px;
                min-height: 40px;
            }
        }
        
        /* Mobile Modal Overlay */
        @media (max-width: 768px) {
            .message-menu::before,
            .emoji-picker::before {
                content: '';
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.3);
                z-index: -1;
                backdrop-filter: blur(2px);
                animation: overlayFadeIn 0.2s ease;
            }
            
            @keyframes overlayFadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            
            /* Prevent body scroll when menu is open */
            body.menu-open {
                overflow: hidden;
                position: fixed;
                width: 100%;
            }
        }
        
        /* User Options Menu */
        .user-options-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 180px;
            overflow: hidden;
            animation: menuSlideIn 0.2s ease;
        }
        
        @keyframes menuSlideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .user-option {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 14px;
            border-bottom: 1px solid #f3f4f6;
        }
        
        .user-option:last-child {
            border-bottom: none;
        }
        
        .user-option:hover {
            background-color: #f8f9fa;
        }
        
        .user-option.block-option {
            color: #dc2626;
        }
        
        .user-option.block-option:hover {
            background-color: #fef2f2;
        }
        
        .user-option.unblock-option {
            color: #16a34a;
        }
        
        .user-option.unblock-option:hover {
            background-color: #f0fdf4;
        }
        
        .user-option i {
            margin-right: 8px;
            width: 16px;
        }
        
        /* Block Confirmation Dialog */
        .block-dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--modal-bg);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: overlayFadeIn 0.3s ease;
        }
        
        .block-dialog {
            background: var(--bg-primary);
            color: var(--text-primary);
            border-radius: 12px;
            padding: 24px;
            max-width: 400px;
            width: 100%;
            box-shadow: 0 20px 40px var(--shadow-medium);
            animation: dialogSlideIn 0.3s ease;
            border: 1px solid var(--border-color);
        }
        
        @keyframes dialogSlideIn {
            from { opacity: 0; transform: scale(0.9) translateY(-20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        
        .dialog-header {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .dialog-header i {
            color: #dc2626;
            font-size: 24px;
            margin-right: 12px;
        }
        
        .dialog-title {
            font-size: 18px;
            font-weight: 600;
            color: #1f2937;
        }
        
        .dialog-content {
            color: #6b7280;
            margin-bottom: 24px;
            line-height: 1.5;
        }
        
        .dialog-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }
        
        .dialog-btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            font-size: 14px;
        }
        
        .dialog-btn-cancel {
            background: #f3f4f6;
            color: #374151;
        }
        
        .dialog-btn-cancel:hover {
            background: #e5e7eb;
        }
        
        .dialog-btn-confirm {
            background: #dc2626;
            color: white;
        }
        
        .dialog-btn-confirm:hover {
            background: #b91c1c;
        }
        
        .dialog-btn-unblock {
            background: #16a34a;
            color: white;
        }
        
        .dialog-btn-unblock:hover {
            background: #15803d;
        }
        
        /* Message Editing Styles */
        .message-edit-container {
            position: relative;
            margin-top: 8px;
        }
        
        .message-edit-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            resize: none;
            max-height: 120px;
            min-height: 40px;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .message-edit-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px var(--accent-shadow);
        }
        
        .message-edit-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 8px;
        }
        
        .edit-cancel-btn, .edit-save-btn {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .edit-save-btn {
            background: var(--success-color);
            color: white;
        }
        
        .edit-save-btn:hover {
            background: var(--success-hover);
        }
        
        .edit-cancel-btn {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }
        
        .edit-cancel-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .message-edited {
            opacity: 0.9;
        }
        
        .edit-indicator {
            font-size: 11px;
            color: var(--text-secondary);
            font-style: italic;
            margin-left: 8px;
            cursor: pointer;
        }
        
        .edit-history-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: pointer;
            text-decoration: underline;
            padding: 0;
            margin-left: 4px;
        }
        
        .edit-history-btn:hover {
            color: var(--text-primary);
        }
        
        .edit-history-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .edit-history-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            width: 100%;
            max-height: 70vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
        }
        
        .edit-history-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .edit-history-title {
            font-size: 18px;
            font-weight: 600;
            color: #1f2937;
        }
        
        .edit-history-close {
            background: none;
            border: none;
            font-size: 24px;
            color: #6b7280;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        
        .edit-history-close:hover {
            background: #f3f4f6;
            color: #374151;
        }
        
        .edit-history-item {
            margin-bottom: 16px;
            padding: 12px;
            background: #f9fafb;
            border-radius: 8px;
            border-left: 3px solid #667eea;
        }
        
        .edit-history-item:last-child {
            margin-bottom: 0;
        }
        
        .edit-history-timestamp {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 4px;
        }
        
        .edit-history-text {
            color: #374151;
            line-height: 1.4;
        }

        /* Message Forwarding Styles */
        .forward-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--modal-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .forward-modal-content {
            background: var(--bg-primary);
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: var(--shadow-medium);
            border: 1px solid var(--border-color);
        }

        .forward-modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .forward-modal-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .close-forward-modal {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            padding: 4px;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-forward-modal:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .forward-search-container {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .forward-search-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            outline: none;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }

        .forward-search-input:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px var(--accent-shadow);
        }

        .forward-contacts-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .forward-contact-item {
            padding: 12px 20px;
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s;
            border-bottom: 1px solid var(--border-color);
        }

        .forward-contact-item:hover {
            background: var(--bg-hover);
        }

        .forward-contact-item.selected {
            background: var(--accent-bg);
            border-color: var(--accent-color);
        }

        .forward-contact-checkbox {
            margin-right: 12px;
            width: 18px;
            height: 18px;
            accent-color: var(--accent-color);
        }

        .forward-contact-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 12px;
            background: #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: #6b7280;
            font-size: 16px;
        }

        .forward-contact-info {
            flex: 1;
        }

        .forward-contact-name {
            font-weight: 500;
            color: #111827;
            margin-bottom: 2px;
        }

        .forward-contact-status {
            font-size: 12px;
            color: #6b7280;
        }

        .forward-modal-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .forward-selected-count {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .forward-actions {
            display: flex;
            gap: 12px;
        }

        .forward-cancel-btn {
            padding: 8px 16px;
            border: 1px solid #d1d5db;
            background: white;
            color: #374151;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .forward-cancel-btn:hover {
            background: #f9fafb;
        }

        .forward-send-btn {
            padding: 8px 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .forward-send-btn:hover {
            background: #2563eb;
        }

        .forward-send-btn:disabled {
            background: #d1d5db;
            cursor: not-allowed;
        }

        .forward-message-preview {
            margin: 16px 20px;
            padding: 12px;
            background: #f9fafb;
            border-radius: 8px;
            border-left: 3px solid #3b82f6;
        }

        .forward-message-preview-label {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .forward-message-preview-content {
            color: #374151;
            font-size: 14px;
            line-height: 1.4;
        }

        /* Message Reply Styles */
        .reply-preview-container {
            background: #f3f4f6;
            border-left: 3px solid #3b82f6;
            border-radius: 8px;
            margin-bottom: 12px;
            padding: 8px 12px;
            position: relative;
            max-width: 100%;
        }

        .reply-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .reply-preview-author {
            font-size: 12px;
            font-weight: 600;
            color: #3b82f6;
        }

        .reply-preview-close {
            background: none;
            border: none;
            color: #6b7280;
            cursor: pointer;
            padding: 2px;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .reply-preview-close:hover {
            background: #e5e7eb;
            color: #374151;
        }

        .reply-preview-content {
            font-size: 13px;
            color: #6b7280;
            line-height: 1.3;
            max-height: 60px;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
        }

        .reply-preview-media {
            font-style: italic;
            color: #9ca3af;
        }

        .replied-message {
            background: #f8fafc;
            border-left: 3px solid #3b82f6;
            border-radius: 6px;
            margin-bottom: 8px;
            padding: 6px 10px;
            max-width: 80%;
        }

        .replied-message-header {
            font-size: 11px;
            font-weight: 600;
            color: #3b82f6;
            margin-bottom: 2px;
        }

        .replied-message-content {
            font-size: 12px;
            color: #6b7280;
            line-height: 1.3;
            max-height: 40px;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .replied-message-media {
            font-style: italic;
            color: #9ca3af;
        }

        .reply-indicator {
            font-size: 11px;
            color: #6b7280;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .reply-indicator i {
            font-size: 10px;
        }

        /* Reply in input area */
        .message-input-container.replying {
            border-top: 1px solid #e5e7eb;
            background: #fafafa;
        }

        .message-input-container.replying .reply-preview-container {
            margin: 8px 16px 0 16px;
            background: white;
        }

        @media (max-width: 768px) {
            .reply-preview-container {
                margin-bottom: 8px;
                padding: 6px 10px;
            }
            
            .reply-preview-content {
                font-size: 12px;
                max-height: 50px;
                -webkit-line-clamp: 2;
            }
            
            .replied-message {
                max-width: 85%;
                padding: 4px 8px;
            }
            
            .replied-message-content {
                font-size: 11px;
                max-height: 35px;
            }
        }

        /* Message Search Styles */
        .message-search-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            z-index: 100;
            display: flex;
            flex-direction: column;
            transform: translateY(-100%);
            transition: transform 0.3s ease;
        }

        .message-search-container.active {
            transform: translateY(0);
        }

        .message-search-header {
            padding: 16px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            gap: 12px;
            background: #f9fafb;
        }

        .message-search-back-btn {
            background: none;
            border: none;
            color: #6b7280;
            font-size: 18px;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .message-search-back-btn:hover {
            background: #e5e7eb;
            color: #374151;
        }

        .message-search-input-wrapper {
            flex: 1;
            position: relative;
        }

        .message-search-input {
            width: 100%;
            padding: 10px 40px 10px 16px;
            border: 1px solid #d1d5db;
            border-radius: 20px;
            font-size: 14px;
            outline: none;
            background: white;
        }

        .message-search-input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .message-search-clear-btn {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #6b7280;
            cursor: pointer;
            padding: 4px;
            border-radius: 50%;
            display: none;
        }

        .message-search-clear-btn.visible {
            display: block;
        }

        .message-search-clear-btn:hover {
            background: #e5e7eb;
            color: #374151;
        }

        .message-search-results {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .message-search-status {
            text-align: center;
            color: #6b7280;
            font-size: 14px;
            padding: 40px 20px;
        }

        .message-search-result {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            border: 1px solid #e5e7eb;
        }

        .message-search-result:hover {
            background: #f9fafb;
        }

        .message-search-result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .message-search-result-sender {
            font-weight: 500;
            color: #374151;
            font-size: 13px;
        }

        .message-search-result-time {
            font-size: 12px;
            color: #9ca3af;
        }

        .message-search-result-content {
            color: #6b7280;
            font-size: 14px;
            line-height: 1.4;
        }

        .message-search-result-highlight {
            background: #fef3c7;
            color: #92400e;
            padding: 0 2px;
            border-radius: 2px;
        }

        .message-search-result-context {
            color: #9ca3af;
            font-size: 12px;
            margin-top: 4px;
            font-style: italic;
        }

        .search-btn {
            background: none;
            border: none;
            color: #6b7280;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .search-btn:hover {
            background: #e5e7eb;
            color: #374151;
        }

        /* Search in chat header */
        .chat-header-search {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Search highlight animation */
        .search-highlight {
            animation: searchHighlight 2s ease-in-out;
        }

        @keyframes searchHighlight {
            0%, 100% { background: transparent; }
            50% { background: rgba(59, 130, 246, 0.1); }
        }

        /* Message Pinning Styles */
        .pinned-messages-container {
            background: #f8fafc;
            border-bottom: 1px solid #e5e7eb;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .pinned-messages-container.has-pins {
            display: block;
        }

        .pinned-messages-header {
            padding: 8px 16px;
            background: #f1f5f9;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            font-weight: 600;
            color: #475569;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .pinned-messages-toggle {
            background: none;
            border: none;
            color: #64748b;
            cursor: pointer;
            font-size: 14px;
            padding: 2px;
        }

        .pinned-messages-toggle:hover {
            color: #334155;
        }

        .pinned-messages-list {
            padding: 8px;
        }

        .pinned-message-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            margin-bottom: 6px;
            padding: 8px 12px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .pinned-message-item:hover {
            background: #f8fafc;
            border-color: #cbd5e1;
        }

        .pinned-message-item:last-child {
            margin-bottom: 0;
        }

        .pinned-message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .pinned-message-sender {
            font-size: 11px;
            font-weight: 600;
            color: #3b82f6;
        }

        .pinned-message-time {
            font-size: 10px;
            color: #9ca3af;
        }

        .pinned-message-content {
            font-size: 13px;
            color: #374151;
            line-height: 1.3;
            max-height: 40px;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .pinned-message-media {
            font-style: italic;
            color: #6b7280;
        }

        .pin-indicator {
            position: absolute;
            top: 4px;
            right: 4px;
            color: #f59e0b;
            font-size: 10px;
        }

        .message-pin-indicator {
            color: #f59e0b;
            font-size: 10px;
            margin-left: 4px;
            opacity: 0.8;
        }

        .pinned-messages-collapsed .pinned-messages-list {
            display: none;
        }

        @media (max-width: 768px) {
            .message-search-header {
                padding: 12px 16px;
            }
            
            .message-search-input {
                padding: 8px 35px 8px 14px;
                font-size: 16px; /* Prevents zoom on iOS */
            }
            
            .message-search-results {
                padding: 12px;
            }
            
            .message-search-result {
                padding: 10px;
            }
        }

        /* Mobile utility classes */
        .mobile-only {
            display: none;
        }
        
        @media (max-width: 768px) {
            .mobile-only {
                display: block;
            }
            
            .desktop-only {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Authentication Screens -->
    <div id="auth-container" class="hidden min-h-screen flex items-center justify-center p-4">
        <!-- Login Form -->
        <div id="login-form" class="glass-effect rounded-2xl p-8 w-full max-w-md shadow-2xl">
            <div class="text-center mb-8">
                <i class="fas fa-shield-alt text-4xl text-white mb-4"></i>
                <div class="flex items-center mb-2">
                    <img src="/static/logo.svg" alt="Enlock Chat" class="w-8 h-8 mr-3">
                    <h1 class="text-3xl font-bold text-white">Enlock Chat</h1>
                </div>
                <p class="text-white/80">Privacy-first messaging platform</p>
            </div>
            
            <form id="login-form-element" class="space-y-6">
                <div>
                    <label class="block text-white/90 text-sm font-medium mb-2">
                        <i class="fas fa-envelope mr-2"></i>Email
                    </label>
                    <input type="email" id="login-email" required 
                           class="w-full px-4 py-3 rounded-lg bg-white/10 border border-white/20 text-white placeholder-white/60 focus:outline-none focus:border-white/50 transition-colors">
                </div>
                
                <div>
                    <label class="block text-white/90 text-sm font-medium mb-2">
                        <i class="fas fa-lock mr-2"></i>Password
                    </label>
                    <input type="password" id="login-password" required 
                           class="w-full px-4 py-3 rounded-lg bg-white/10 border border-white/20 text-white placeholder-white/60 focus:outline-none focus:border-white/50 transition-colors">
                </div>
                
                <button type="submit" class="w-full btn-primary py-3 rounded-lg font-medium text-white">
                    <i class="fas fa-sign-in-alt mr-2"></i>Sign In
                </button>
            </form>
            
            <div class="mt-6 text-center">
                <p class="text-white/80">Don't have an account? 
                    <button id="show-signup" class="text-white underline hover:no-underline">Sign up</button>
                </p>
            </div>
        </div>
        
        <!-- Signup Form -->
        <div id="signup-form" class="glass-effect rounded-2xl p-8 w-full max-w-md shadow-2xl hidden">
            <div class="text-center mb-8">
                <i class="fas fa-user-plus text-4xl text-white mb-4"></i>
                <div class="flex items-center mb-2">
                    <img src="/static/logo.svg" alt="Enlock Chat" class="w-8 h-8 mr-3">
                    <h1 class="text-3xl font-bold text-white">Join Enlock Chat</h1>
                </div>
                <p class="text-white/80">Create your secure account</p>
            </div>
            
            <form id="signup-form-element" class="space-y-6">
                <div>
                    <label class="block text-white/90 text-sm font-medium mb-2">
                        <i class="fas fa-user mr-2"></i>Display Name
                    </label>
                    <input type="text" id="signup-name" required 
                           class="w-full px-4 py-3 rounded-lg bg-white/10 border border-white/20 text-white placeholder-white/60 focus:outline-none focus:border-white/50 transition-colors"
                           placeholder="John Doe">
                </div>
                
                <div>
                    <label class="block text-white/90 text-sm font-medium mb-2">
                        <i class="fas fa-at mr-2"></i>Username
                    </label>
                    <input type="text" id="signup-username" required 
                           class="w-full px-4 py-3 rounded-lg bg-white/10 border border-white/20 text-white placeholder-white/60 focus:outline-none focus:border-white/50 transition-colors"
                           placeholder="johndoe" pattern="[a-zA-Z0-9_]{3,20}">
                    <small class="text-white/60">3-20 characters, letters, numbers, and underscores only</small>
                </div>
                
                <div>
                    <label class="block text-white/90 text-sm font-medium mb-2">
                        <i class="fas fa-envelope mr-2"></i>Email
                    </label>
                    <input type="email" id="signup-email" required 
                           class="w-full px-4 py-3 rounded-lg bg-white/10 border border-white/20 text-white placeholder-white/60 focus:outline-none focus:border-white/50 transition-colors">
                </div>
                
                <div>
                    <label class="block text-white/90 text-sm font-medium mb-2">
                        <i class="fas fa-lock mr-2"></i>Password
                    </label>
                    <input type="password" id="signup-password" required minlength="6"
                           class="w-full px-4 py-3 rounded-lg bg-white/10 border border-white/20 text-white placeholder-white/60 focus:outline-none focus:border-white/50 transition-colors">
                    <small class="text-white/60">Minimum 6 characters</small>
                </div>
                
                <button type="submit" class="w-full btn-primary py-3 rounded-lg font-medium text-white">
                    <i class="fas fa-user-plus mr-2"></i>Create Account
                </button>
            </form>
            
            <div class="mt-6 text-center">
                <p class="text-white/80">Already have an account? 
                    <button id="show-login" class="text-white underline hover:no-underline">Sign in</button>
                </p>
            </div>
        </div>
    </div>

    <!-- Main Chat Interface -->
    <div id="chat-interface" class="hidden h-screen flex">
        <!-- Sidebar -->
        <div id="chat-sidebar" class="chat-sidebar w-80 flex flex-col border-r border-gray-200">
            <!-- Header -->
            <div class="p-4 border-b border-gray-200">
                <div class="flex items-center justify-between mb-4">
                    <div class="flex items-center space-x-3">
                        <div class="relative">
                            <div class="profile-avatar">
                                <i class="fas fa-user"></i>
                            </div>
                            <div class="online-indicator"></div>
                        </div>
                        <div>
                            <h3 id="current-user-name" class="font-semibold text-gray-900"></h3>
                            <p id="current-user-email" class="text-sm text-gray-500"></p>
                        </div>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button id="dark-mode-toggle" class="dark-mode-toggle" title="Toggle dark mode">
                            <i class="fas fa-moon dark-icon"></i>
                            <i class="fas fa-sun light-icon hidden"></i>
                        </button>
                        <button id="logout-btn" class="text-gray-500 hover:text-gray-700 p-2 rounded-lg hover:bg-gray-100">
                            <i class="fas fa-sign-out-alt"></i>
                        </button>
                    </div>
                </div>
                
                <!-- Search -->
                <div class="relative">
                    <i class="fas fa-search absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400"></i>
                    <input type="text" id="search-users" placeholder="Search users..." 
                           class="search-input w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:outline-none">
                </div>
            </div>
            
            <!-- Encryption Status -->
            <div class="px-4 py-2 bg-green-50 border-b border-gray-200">
                <div class="encryption-badge">
                    <i class="fas fa-shield-alt"></i>
                    <span id="encryption-status">End-to-End Encrypted</span>
                </div>
            </div>
            
            <!-- Search Results -->
            <div id="search-results" class="hidden p-4 border-b border-gray-200">
                <h4 class="font-medium text-gray-900 mb-3">Search Results</h4>
                <div id="search-results-list" class="space-y-2"></div>
            </div>
            
            <!-- Chat List -->
            <div class="flex-1 overflow-y-auto">
                <div class="p-4">
                    <h4 class="font-medium text-gray-900 mb-3">Recent Chats</h4>
                    <div id="chat-list" class="space-y-2">
                        <!-- Chat items will be populated here -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Chat Area -->
        <div class="flex-1 flex flex-col chat-main">
            <!-- Chat Header -->
            <div id="chat-header" class="hidden p-4 border-b border-gray-200 bg-white">
                <div class="flex items-center space-x-3">
                    <button id="mobile-back-btn" class="mobile-back-btn mobile-only">
                        <i class="fas fa-arrow-left"></i>
                    </button>
                    <div class="relative">
                        <div id="chat-user-avatar" class="profile-avatar">
                            <i class="fas fa-user"></i>
                        </div>
                        <div class="online-indicator"></div>
                    </div>
                    <div class="flex-1">
                        <h3 id="chat-user-name" class="font-semibold text-gray-900"></h3>
                        <p id="chat-user-status" class="text-sm text-gray-500">Online</p>
                    </div>
                    <!-- Search button -->
                    <button id="message-search-btn" class="search-btn" title="Search messages">
                        <i class="fas fa-search"></i>
                    </button>
                    <!-- Desktop menu button -->
                    <button id="chat-options-btn" class="hidden md:block p-2 text-gray-600 hover:bg-gray-100 rounded-lg transition-colors">
                        <i class="fas fa-ellipsis-v"></i>
                    </button>
                    <!-- Mobile menu button -->
                    <button id="mobile-menu-btn" class="mobile-only p-2 text-gray-600 hover:bg-gray-100 rounded-lg">
                        <i class="fas fa-ellipsis-v"></i>
                    </button>
                </div>
            </div>
            
            <!-- Pinned Messages -->
            <div id="pinned-messages-container" class="pinned-messages-container">
                <div class="pinned-messages-header">
                    <span>Pinned Messages</span>
                    <button class="pinned-messages-toggle" onclick="togglePinnedMessages()">
                        <i class="fas fa-chevron-up" id="pinned-toggle-icon"></i>
                    </button>
                </div>
                <div class="pinned-messages-list" id="pinned-messages-list">
                    <!-- Pinned messages will be populated here -->
                </div>
            </div>
            
            <!-- Welcome Screen -->
            <div id="welcome-screen" class="flex-1 flex items-center justify-center">
                <div class="text-center">
                    <i class="fas fa-comments text-6xl text-gray-300 mb-4"></i>
                    <div class="flex items-center mb-2">
                        <img src="/static/logo.svg" alt="Enlock Chat" class="w-6 h-6 mr-2">
                        <h2 class="text-2xl font-semibold text-gray-800">Welcome to Enlock Chat</h2>
                    </div>
                    <p class="text-gray-600">Search for users to start a secure conversation</p>
                </div>
            </div>
            
            <!-- Messages Area -->
            <div id="messages-container" class="hidden flex-1 overflow-y-auto p-4">
                <!-- Messages will be populated here -->
            </div>
            
            <!-- Message Search -->
            <div id="message-search-container" class="message-search-container">
                <div class="message-search-header">
                    <button class="message-search-back-btn" onclick="closeMessageSearch()">
                        <i class="fas fa-arrow-left"></i>
                    </button>
                    <div class="message-search-input-wrapper">
                        <input type="text" id="message-search-input" class="message-search-input" placeholder="Search messages...">
                        <button class="message-search-clear-btn" onclick="clearMessageSearch()">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
                <div class="message-search-results">
                    <div id="message-search-status" class="message-search-status">
                        Type to search through your conversation
                    </div>
                    <div id="message-search-results-list"></div>
                </div>
            </div>
            
            <!-- Message Input -->
            <div id="message-input-container" class="hidden p-4 border-t border-gray-200 bg-white">
                <form id="message-form" class="flex space-x-1">
                    <div class="file-upload-area" id="file-upload-btn" title="Share files (images, videos, documents)">
                        <i class="fas fa-paperclip text-gray-500"></i>
                        <input type="file" id="file-input" class="hidden" accept="image/*,video/*,.pdf,.doc,.docx,.txt,.zip,.rar" multiple>
                    </div>
                    <textarea id="message-input" placeholder="Type a message... (Shift+Enter for new line)" 
                           rows="1"
                           class="flex-1 px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:border-blue-500 resize-none overflow-y-auto"
                           style="min-height: 44px; max-height: 150px; line-height: 1.4;"></textarea>
                    <button type="submit" class="btn-primary px-6 py-3 rounded-lg text-white font-medium hover:shadow-lg transition-all">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </form>
                
                <!-- Upload Progress -->
                <div id="upload-progress-container" class="hidden mt-3">
                    <div class="upload-progress">
                        <div class="flex items-center justify-between mb-2">
                            <span class="text-sm font-medium text-gray-700">Uploading file...</span>
                            <span id="upload-percentage" class="text-sm text-gray-500">0%</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
                
                <!-- File Preview -->
                <div id="file-preview" class="hidden mt-3 p-3 bg-gray-50 rounded-lg border">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center space-x-3">
                            <i id="file-icon" class="text-2xl text-gray-600"></i>
                            <div>
                                <p id="file-name" class="text-sm font-medium text-gray-800"></p>
                                <p id="file-size" class="text-xs text-gray-500"></p>
                            </div>
                        </div>
                        <button id="remove-file" class="text-red-500 hover:text-red-700 transition-colors">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Loading Overlay -->
    <div id="loading-overlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="glass-effect rounded-lg p-8 text-center">
            <i class="fas fa-shield-alt text-4xl text-white mb-4"></i>
            <div class="flex items-center mb-2">
                <img src="/static/logo.svg" alt="Enlock Chat" class="w-6 h-6 mr-2">
                <h2 class="text-2xl font-bold text-white">Enlock Chat</h2>
            </div>
            <div class="flex items-center justify-center space-x-2 mb-4">
                <i class="fas fa-spinner fa-spin text-lg text-white"></i>
                <p class="text-white/90">Initializing secure connection...</p>
            </div>
            <div class="w-48 bg-white/20 rounded-full h-1 mx-auto">
                <div class="bg-white h-1 rounded-full animate-pulse" style="width: 60%"></div>
            </div>
        </div>
    </div>
    
    <!-- Error Modal -->
    <div id="error-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
            <div class="flex items-center mb-4">
                <i class="fas fa-exclamation-triangle text-red-500 text-xl mr-3"></i>
                <h3 class="text-lg font-semibold text-gray-900">Error</h3>
            </div>
            <p id="error-message" class="text-gray-700 mb-4"></p>
            <button id="close-error" class="w-full bg-red-500 text-white py-2 rounded-lg hover:bg-red-600 transition-colors">
                Close
            </button>
        </div>
    </div>
    
    <!-- Image/Video Lightbox -->
    <div id="lightbox" class="lightbox">
        <div class="lightbox-close" id="lightbox-close">
            <i class="fas fa-times"></i>
        </div>
        <img id="lightbox-content" class="lightbox-content" alt="Full size view">
    </div>

    <!-- Firebase and App Scripts -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            createUserWithEmailAndPassword,
            signInWithEmailAndPassword,
            signOut,
            onAuthStateChanged,
            updateProfile
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            collection, 
            query, 
            addDoc, 
            onSnapshot, 
            orderBy, 
            serverTimestamp,
            setDoc,
            doc,
            getDoc,
            getDocs,
            deleteDoc,
            where,
            limit
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { 
            getStorage, 
            ref, 
            uploadBytes, 
            getDownloadURL, 
            deleteObject 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCf_A4k-fXQb2MRXaUueqLOwBbS6vBoVoo",
            authDomain: "myautth-v8iv5q.firebaseapp.com",
            projectId: "myautth-v8iv5q",
            storageBucket: "myautth-v8iv5q.appspot.com",
            messagingSenderId: "1084690987173",
            appId: "1:1084690987173:web:484f1a74d52004a767354c"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);

        // Global variables
        let currentUser = null;
        let currentChatUser = null;
        let e2eKey = null;
        let messageListeners = new Map();
        let reactionListeners = new Map();
        let recentChatsListener = null;
        let isSendingMessage = false; // Flag to prevent multiple messages
        
        // Common emoji reactions (WhatsApp style)
        const commonEmojis = ['👍', '❤️', '😂', '😮', '😢', '😡'];

        // Dark Mode Functions
        function initializeDarkMode() {
            const savedTheme = localStorage.getItem('darkMode');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            
            if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                enableDarkMode();
            } else {
                disableDarkMode();
            }
        }
        
        function toggleDarkMode() {
            const isDarkMode = document.documentElement.getAttribute('data-theme') === 'dark';
            
            if (isDarkMode) {
                disableDarkMode();
            } else {
                enableDarkMode();
            }
        }
        
        function enableDarkMode() {
            document.documentElement.setAttribute('data-theme', 'dark');
            localStorage.setItem('darkMode', 'dark');
            
            const darkIcon = document.querySelector('.dark-icon');
            const lightIcon = document.querySelector('.light-icon');
            if (darkIcon && lightIcon) {
                darkIcon.classList.add('hidden');
                lightIcon.classList.remove('hidden');
            }
        }
        
        function disableDarkMode() {
            document.documentElement.setAttribute('data-theme', 'light');
            localStorage.setItem('darkMode', 'light');
            
            const darkIcon = document.querySelector('.dark-icon');
            const lightIcon = document.querySelector('.light-icon');
            if (darkIcon && lightIcon) {
                darkIcon.classList.remove('hidden');
                lightIcon.classList.add('hidden');
            }
        }

        // Link Preview Functions
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        const linkPreviewCache = new Map();
        
        function detectURLs(text) {
            const matches = text.match(urlRegex);
            return matches ? matches.map(url => url.replace(/[.,;!?]$/, '')) : [];
        }
        
        function makeLinksClickable(text) {
            return text.replace(urlRegex, (url) => {
                const cleanUrl = url.replace(/[.,;!?]$/, '');
                return `<a href="${cleanUrl}" target="_blank" rel="noopener noreferrer" class="message-link">${url}</a>`;
            });
        }
        
        async function fetchLinkPreview(url) {
            // Check cache first
            if (linkPreviewCache.has(url)) {
                return linkPreviewCache.get(url);
            }
            
            try {
                // Use a CORS proxy service for fetching metadata
                const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                const response = await fetch(proxyUrl);
                const data = await response.json();
                
                if (!data.contents) {
                    throw new Error('Failed to fetch content');
                }
                
                const parser = new DOMParser();
                const doc = parser.parseFromString(data.contents, 'text/html');
                
                // Extract metadata
                const preview = {
                    url: url,
                    title: getMetaContent(doc, 'og:title') || 
                           getMetaContent(doc, 'twitter:title') || 
                           doc.title || 
                           getDomainFromUrl(url),
                    description: getMetaContent(doc, 'og:description') || 
                                getMetaContent(doc, 'twitter:description') || 
                                getMetaContent(doc, 'description') || '',
                    image: getMetaContent(doc, 'og:image') || 
                           getMetaContent(doc, 'twitter:image') || '',
                    domain: getDomainFromUrl(url),
                    favicon: getFaviconUrl(doc, url)
                };
                
                // Cache the result
                linkPreviewCache.set(url, preview);
                return preview;
                
            } catch (error) {
                console.log('Error fetching link preview:', error);
                
                // Return basic preview on error
                const basicPreview = {
                    url: url,
                    title: getDomainFromUrl(url),
                    description: '',
                    image: '',
                    domain: getDomainFromUrl(url),
                    favicon: '',
                    error: true
                };
                
                linkPreviewCache.set(url, basicPreview);
                return basicPreview;
            }
        }
        
        function getMetaContent(doc, property) {
            const meta = doc.querySelector(`meta[property="${property}"]`) || 
                        doc.querySelector(`meta[name="${property}"]`);
            return meta ? meta.getAttribute('content') : null;
        }
        
        function getDomainFromUrl(url) {
            try {
                return new URL(url).hostname.replace('www.', '');
            } catch {
                return url;
            }
        }
        
        function getFaviconUrl(doc, url) {
            const favicon = doc.querySelector('link[rel*="icon"]');
            if (favicon) {
                const href = favicon.getAttribute('href');
                if (href.startsWith('http')) {
                    return href;
                } else {
                    try {
                        const urlObj = new URL(url);
                        return `${urlObj.protocol}//${urlObj.host}${href.startsWith('/') ? '' : '/'}${href}`;
                    } catch {
                        return '';
                    }
                }
            }
            
            try {
                const urlObj = new URL(url);
                return `${urlObj.protocol}//${urlObj.host}/favicon.ico`;
            } catch {
                return '';
            }
        }
        
        function createLinkPreview(preview) {
            const previewElement = document.createElement('div');
            previewElement.className = 'link-preview';
            previewElement.onclick = () => window.open(preview.url, '_blank', 'noopener,noreferrer');
            
            let imageHTML = '';
            if (preview.image && !preview.error) {
                imageHTML = `
                    <img src="${preview.image}" 
                         alt="${preview.title}" 
                         class="link-preview-image"
                         onerror="this.style.display='none'">
                `;
            }
            
            let faviconHTML = '';
            if (preview.favicon && !preview.error) {
                faviconHTML = `
                    <img src="${preview.favicon}" 
                         alt="${preview.domain}" 
                         class="link-preview-favicon"
                         onerror="this.style.display='none'">
                `;
            }
            
            previewElement.innerHTML = `
                ${imageHTML}
                <div class="link-preview-content">
                    <h4 class="link-preview-title">${preview.title || preview.domain}</h4>
                    ${preview.description ? `<p class="link-preview-description">${preview.description}</p>` : ''}
                    <div class="link-preview-domain">
                        ${faviconHTML}
                        ${preview.domain}
                    </div>
                </div>
            `;
            
            return previewElement;
        }
        
        function createLinkPreviewLoading() {
            const loadingElement = document.createElement('div');
            loadingElement.className = 'link-preview';
            loadingElement.innerHTML = `
                <div class="link-preview-loading">
                    <i class="fas fa-spinner fa-spin"></i>
                    Loading link preview...
                </div>
            `;
            return loadingElement;
        }
        
        async function processMessageLinks(messageElement, messageText) {
            const urls = detectURLs(messageText);
            
            if (urls.length === 0) return;
            
            const messageContent = messageElement.querySelector('.message-content');
            if (!messageContent) return;
            
            for (const url of urls) {
                // Create loading preview
                const loadingPreview = createLinkPreviewLoading();
                messageContent.appendChild(loadingPreview);
                
                try {
                    // Fetch and display actual preview
                    const preview = await fetchLinkPreview(url);
                    const previewElement = createLinkPreview(preview);
                    
                    // Replace loading with actual preview
                    messageContent.replaceChild(previewElement, loadingPreview);
                } catch (error) {
                    console.log('Error creating link preview:', error);
                    // Remove loading preview on error
                    if (loadingPreview.parentNode) {
                        loadingPreview.remove();
                    }
                }
            }
        }

        // Encryption functions
        const algo = { name: "AES-GCM", length: 256 };
        let chatKeys = new Map(); // Store keys per chat

        async function generateE2EKey() {
            try {
                if (!window.crypto || !window.crypto.subtle) {
                    console.warn("Web Crypto API not available. Running in insecure context.");
                    document.getElementById('encryption-status').textContent = 'Not Encrypted (HTTP)';
                    document.getElementById('encryption-status').parentElement.className = 'bg-yellow-50 border-yellow-200 px-4 py-2';
                    document.getElementById('encryption-status').parentElement.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
                    return;
                }

                console.log("Encryption system initialized (using per-chat shared keys)");
                document.getElementById('encryption-status').textContent = 'End-to-End Encrypted';
                
            } catch (error) {
                console.error("Error initializing encryption:", error);
                document.getElementById('encryption-status').textContent = 'Encryption Error';
                showError("Encryption setup failed. Please refresh the page.");
            }
        }

        // Get or create shared encryption key for a specific chat
        async function getSharedKeyForChat(chatId) {
            try {
                // Check if we already have the key in memory
                if (chatKeys.has(chatId)) {
                    return chatKeys.get(chatId);
                }

                // Try to load from Firebase
                const chatRef = doc(db, 'chats', chatId);
                const chatDoc = await getDoc(chatRef);
                
                if (chatDoc.exists() && chatDoc.data().encryptionKey) {
                    // Key exists in Firebase, import it
                    const keyData = chatDoc.data().encryptionKey;
                    const keyBuffer = new Uint8Array(keyData).buffer;
                    const importedKey = await crypto.subtle.importKey(
                        "raw",
                        keyBuffer,
                        algo,
                        true,
                        ["encrypt", "decrypt"]
                    );
                    chatKeys.set(chatId, importedKey);
                    console.log(`Loaded shared encryption key for chat ${chatId}`);
                    return importedKey;
                }

                // No key exists, generate new one and save to Firebase
                const newKey = await crypto.subtle.generateKey(algo, true, ["encrypt", "decrypt"]);
                const exported = await crypto.subtle.exportKey("raw", newKey);
                const keyData = Array.from(new Uint8Array(exported));

                // Save to Firebase so both users can access it
                await setDoc(chatRef, {
                    encryptionKey: keyData,
                    createdAt: serverTimestamp()
                }, { merge: true });

                chatKeys.set(chatId, newKey);
                console.log(`Generated and saved new shared encryption key for chat ${chatId}`);
                return newKey;

            } catch (error) {
                console.error("Error getting shared key:", error);
                // Return null to allow unencrypted fallback
                return null;
            }
        }

        // Load the correct key when switching chats
        async function loadKeyForCurrentChat() {
            const chatId = getCurrentChatId();
            if (!chatId) {
                e2eKey = null;
                return;
            }

            e2eKey = await getSharedKeyForChat(chatId);
            if (e2eKey) {
                console.log(`Active encryption key set for chat ${chatId}`);
            } else {
                console.warn(`No encryption key available for chat ${chatId}`);
            }
        }

        // Safe decryption wrapper with error handling
        async function safeDecryptMessage(messageData) {
            try {
                // If it's already a string, return it
                if (typeof messageData === 'string') {
                    return messageData;
                }
                
                // If it has plaintext, return it
                if (messageData && messageData.text && !messageData.ciphertext) {
                    return messageData.text;
                }
                
                // If no ciphertext, return fallback
                if (!messageData || !messageData.ciphertext) {
                    return "Message";
                }
                
                // Try to decrypt
                const decrypted = await decryptMessage(messageData);
                
                // Check if decryption failed (error messages start with ❌ or 🔒)
                if (decrypted && (decrypted.includes('❌') || decrypted.includes('🔒'))) {
                    return "🔒 Encrypted message";
                }
                
                return decrypted;
            } catch (error) {
                console.error('Safe decrypt failed:', error);
                return "🔒 Encrypted message";
            }
        }

        // Completely robust decryption with multiple fallback strategies
        async function bulletproofDecryptMessage(messageData) {
            // Strategy 1: Check if it's already plaintext
            if (typeof messageData === 'string') {
                return messageData;
            }
            
            if (messageData && messageData.text && !messageData.ciphertext) {
                return messageData.text;
            }
            
            // Strategy 2: Handle missing or invalid data
            if (!messageData || (!messageData.ciphertext && !messageData.text)) {
                return "📝 Message";
            }
            
            // Strategy 3: Try safe decryption if we have encrypted data
            if (messageData.ciphertext && messageData.iv) {
                try {
                    const result = await safeDecryptMessage(messageData);
                    // Accept result unless it contains error indicators
                    if (result && !result.includes('❌') && !result.includes('🔒')) {
                        return result;
                    }
                    // If decryption failed due to key mismatch, show appropriate message
                    if (result && result.includes('🔒')) {
                        return "🔒 Encrypted message";
                    }
                } catch (error) {
                    console.warn('Decryption attempt failed, using fallback');
                }
            }
            
            // Strategy 4: Final fallbacks
            if (messageData.text) {
                return messageData.text;
            }
            
            if (messageData.fileName) {
                return `📎 ${messageData.fileName}`;
            }
            
            if (messageData.type === 'image' || messageData.imageUrl) {
                return "🖼️ Image";
            }
            
            if (messageData.type === 'voice' || messageData.voiceUrl) {
                return "🎵 Voice message";
            }
            
            if (messageData.type === 'file' || messageData.fileUrl) {
                return "📎 File";
            }
            
            return "💬 Message";
        }

        // Clear all cached keys
        async function clearStoredKey() {
            try {
                chatKeys.clear();
                e2eKey = null;
                console.log("Cleared all cached encryption keys");
            } catch (error) {
                console.error("Failed to clear cached keys:", error);
            }
        }

        // Helper function to reset encryption key for current chat
        async function resetEncryptionKey() {
            try {
                const chatId = getCurrentChatId();
                if (!chatId) {
                    showError("No active chat selected");
                    return false;
                }

                console.log(`Resetting encryption key for chat ${chatId}...`);
                
                // Remove from cache
                chatKeys.delete(chatId);
                
                // Generate new key and save to Firebase
                const newKey = await crypto.subtle.generateKey(algo, true, ["encrypt", "decrypt"]);
                const exported = await crypto.subtle.exportKey("raw", newKey);
                const keyData = Array.from(new Uint8Array(exported));

                const chatRef = doc(db, 'chats', chatId);
                await setDoc(chatRef, {
                    encryptionKey: keyData,
                    keyResetAt: serverTimestamp()
                }, { merge: true });

                chatKeys.set(chatId, newKey);
                e2eKey = newKey;

                showSuccess("Encryption key reset successfully. Both users will use the new key.");
                console.log("Encryption key has been reset. Messages encrypted with old key may not be readable.");
                return true;
            } catch (error) {
                console.error("Failed to reset encryption key:", error);
                showError("Failed to reset encryption key. Please try again.");
                return false;
            }
        }

        // Helper function to check encryption status
        function checkEncryptionStatus() {
            const chatId = getCurrentChatId();
            console.log("=== Encryption Status ===");
            console.log("Current Chat ID:", chatId || "No active chat");
            console.log("Active Key Loaded:", !!e2eKey);
            console.log("Cached Keys Count:", chatKeys.size);
            if (chatId) {
                console.log(`Key for current chat (${chatId}):`, chatKeys.has(chatId) ? "✅ Cached" : "❌ Not cached");
            }
            console.log("========================");
            
            if (!e2eKey && chatId) {
                console.warn("⚠️ No encryption key loaded for active chat!");
                console.log("Try running: await loadKeyForCurrentChat()");
            }
        }

        // Make functions available globally for debugging
        window.resetEncryptionKey = resetEncryptionKey;
        window.clearStoredKey = clearStoredKey;
        window.loadKeyForCurrentChat = loadKeyForCurrentChat;
        window.checkEncryptionStatus = checkEncryptionStatus;

        async function encryptMessage(plaintext) {
            if (!e2eKey) {
                return {
                    ciphertext: Array.from(new TextEncoder().encode(plaintext)),
                    iv: Array.from(new Uint8Array(12))
                };
            }
            
            const encoder = new TextEncoder();
            const data = encoder.encode(plaintext);
            const iv = crypto.getRandomValues(new Uint8Array(12));

            const ciphertext = await crypto.subtle.encrypt(
                { name: algo.name, iv: iv },
                e2eKey,
                data
            );
            
            return {
                ciphertext: Array.from(new Uint8Array(ciphertext)),
                iv: Array.from(iv)
            };
        }

        async function decryptMessage(payload) {
            // Validate payload structure
            if (!payload) {
                console.error("Decryption failed: No payload provided");
                return "❌ Invalid message format";
            }

            // Check if payload has required properties
            if (!payload.ciphertext || !payload.iv) {
                console.error("Decryption failed: Missing ciphertext or IV");
                // Try to return as plaintext if it's unencrypted
                if (typeof payload === 'string') {
                    return payload;
                } else if (payload.text) {
                    return payload.text;
                }
                return "❌ Invalid message format";
            }

            // If no encryption key, try to handle as unencrypted message
            if (!e2eKey) {
                console.warn("No encryption key available for current chat. Try loading the chat again.");
                console.warn("You can also try: await loadKeyForCurrentChat()");
                try {
                    // Check if it's already a string
                    if (typeof payload.ciphertext === 'string') {
                        return payload.ciphertext;
                    }
                    
                    // Try to decode as Uint8Array
                    const decoder = new TextDecoder();
                    return decoder.decode(new Uint8Array(payload.ciphertext));
                } catch (error) {
                    console.error("Failed to decode unencrypted message:", error);
                    return "❌ Cannot decode message - no encryption key";
                }
            }
            
            try {
                // Validate IV and ciphertext arrays
                if (!Array.isArray(payload.iv) || !Array.isArray(payload.ciphertext)) {
                    throw new Error("Invalid payload format: IV and ciphertext must be arrays");
                }

                // Validate IV length (should be 12 bytes for AES-GCM)
                if (payload.iv.length !== 12) {
                    throw new Error(`Invalid IV length: expected 12, got ${payload.iv.length}`);
                }

                // Convert arrays to Uint8Array
                const iv = new Uint8Array(payload.iv);
                const ciphertext = new Uint8Array(payload.ciphertext);

                // Attempt decryption
                const decryptedData = await crypto.subtle.decrypt(
                    { name: algo.name, iv: iv },
                    e2eKey,
                    ciphertext
                );
                
                const decoder = new TextDecoder();
                const decryptedText = decoder.decode(decryptedData);
                
                // Validate decrypted text
                if (!decryptedText || decryptedText.length === 0) {
                    throw new Error("Decrypted message is empty");
                }
                
                return decryptedText;
                
            } catch (error) {
                console.error("Decryption failed:", error);
                console.error("Payload details:", {
                    hasKey: !!e2eKey,
                    ivLength: payload.iv?.length,
                    ciphertextLength: payload.ciphertext?.length,
                    payloadType: typeof payload,
                    errorName: error.name,
                    errorMessage: error.message
                });

                // Specific error messages based on error type
                if (error.name === 'InvalidAccessError') {
                    console.warn("Invalid encryption key - key mismatch detected");
                    return "🔒 Message encrypted with different key";
                } else if (error.name === 'OperationError' || error.message.includes('operation failed')) {
                    // This typically means key mismatch - the message was encrypted with a different key
                    console.warn("Key mismatch - message encrypted with different encryption key");
                    return "🔒 Message encrypted with different key";
                } else if (error.message.includes('Invalid IV length')) {
                    return "❌ Invalid message format";
                } else {
                    console.warn("Decryption failed with unknown error:", error.name);
                    return "🔒 Unable to decrypt message";
                }
            }
        }

        // Utility functions
        function showError(message) {
            document.getElementById('error-message').textContent = message;
            document.getElementById('error-modal').classList.remove('hidden');
        }

        function hideError() {
            document.getElementById('error-modal').classList.add('hidden');
        }

        function showSuccess(message) {
            // Create a success notification
            const successDiv = document.createElement('div');
            successDiv.className = 'fixed top-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 transition-all duration-300';
            successDiv.innerHTML = `
                <div class="flex items-center space-x-2">
                    <i class="fas fa-check-circle"></i>
                    <span>${message}</span>
                </div>
            `;
            
            document.body.appendChild(successDiv);
            
            // Animate in
            setTimeout(() => {
                successDiv.style.transform = 'translateX(0)';
                successDiv.style.opacity = '1';
            }, 100);
            
            // Auto remove after 3 seconds
            setTimeout(() => {
                successDiv.style.transform = 'translateX(100%)';
                successDiv.style.opacity = '0';
                setTimeout(() => {
                    if (successDiv.parentNode) {
                        successDiv.parentNode.removeChild(successDiv);
                    }
                }, 300);
            }, 3000);
        }

        function showLoading(message = 'Initializing secure connection...') {
            document.getElementById('loading-overlay').classList.remove('hidden');
            const loadingText = document.querySelector('#loading-overlay p');
            if (loadingText) {
                loadingText.textContent = message;
            }
        }

        function hideLoading() {
            document.getElementById('loading-overlay').classList.add('hidden');
        }

        function generateChatId(user1Id, user2Id) {
            return [user1Id, user2Id].sort().join('_');
        }

        function getCurrentChatId() {
            if (!currentChatUser || !currentUser) return null;
            return generateChatId(currentUser.uid, currentChatUser.uid);
        }

        // Date formatting utilities for message grouping
        function formatDateGroup(date) {
            const now = new Date();
            const messageDate = new Date(date);
            const diffTime = Math.abs(now - messageDate);
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            
            if (messageDate.toDateString() === now.toDateString()) {
                return 'Today';
            }
            
            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            if (messageDate.toDateString() === yesterday.toDateString()) {
                return 'Yesterday';
            }
            
            if (diffDays < 7) {
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                return dayNames[messageDate.getDay()];
            }
            
            return messageDate.toLocaleDateString([], {
                year: messageDate.getFullYear() === now.getFullYear() ? undefined : 'numeric',
                month: 'short',
                day: 'numeric'
            });
        }

        function isSameDay(date1, date2) {
            return date1.toDateString() === date2.toDateString();
        }

        function formatTimestamp(timestamp) {
            if (!timestamp) return '';
            
            const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
            const now = new Date();
            
            // If it's today, show time only
            if (isSameDay(date, now)) {
                return date.toLocaleTimeString([], {
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }
            
            // If it's this year, show month/day and time
            if (date.getFullYear() === now.getFullYear()) {
                return date.toLocaleDateString([], {
                    month: 'short',
                    day: 'numeric'
                }) + ' at ' + date.toLocaleTimeString([], {
                    hour: '2-digit',
                    minute: '2-digit'
                });
            }
            
            // Otherwise show full date and time
            return date.toLocaleDateString([], {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            }) + ' at ' + date.toLocaleTimeString([], {
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Helper function for forwarded messages
        function getForwardedHeader(isForwarded, isMyMessage) {
            if (!isForwarded) return '';
            
            return `
                <div class="forwarded-message-header" style="margin-bottom: 8px; font-size: 12px; color: ${isMyMessage ? 'rgba(255,255,255,0.7)' : '#6b7280'}; display: flex; align-items: center;">
                    <i class="fas fa-share" style="margin-right: 4px;"></i>
                    <span>Forwarded</span>
                </div>
            `;
        }

        // Helper function for replied messages
        function getRepliedMessageHeader(replyTo, isMyMessage) {
            if (!replyTo) return '';
            
            let replyContent = '';
            switch (replyTo.type) {
                case 'text':
                    replyContent = replyTo.content.length > 50 ? 
                        replyTo.content.substring(0, 50) + '...' : 
                        replyTo.content;
                    break;
                case 'image':
                    replyContent = '<span class="replied-message-media">📷 Image</span>';
                    break;
                case 'file':
                    replyContent = `<span class="replied-message-media">📎 ${replyTo.content}</span>`;
                    break;
                case 'voice':
                    replyContent = '<span class="replied-message-media">🎵 Voice message</span>';
                    break;
                default:
                    replyContent = 'Message';
            }
            
            return `
                <div class="replied-message">
                    <div class="replied-message-header">${replyTo.senderName}</div>
                    <div class="replied-message-content">${replyContent}</div>
                </div>
            `;
        }

        // File handling functions
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function getFileIcon(fileName) {
            const extension = fileName.split('.').pop().toLowerCase();
            const iconMap = {
                pdf: { icon: '📄', color: '#ef4444' },
                doc: { icon: '📝', color: '#2563eb' },
                docx: { icon: '📝', color: '#2563eb' },
                txt: { icon: '📄', color: '#6b7280' },
                zip: { icon: '🗜️', color: '#8b5cf6' },
                rar: { icon: '🗜️', color: '#8b5cf6' },
                jpg: { icon: '🖼️', color: '#10b981' },
                jpeg: { icon: '🖼️', color: '#10b981' },
                png: { icon: '🖼️', color: '#10b981' },
                gif: { icon: '🖼️', color: '#10b981' },
                mp4: { icon: '🎥', color: '#f59e0b' },
                avi: { icon: '🎥', color: '#f59e0b' },
                mov: { icon: '🎥', color: '#f59e0b' },
                mkv: { icon: '🎥', color: '#f59e0b' }
            };
            return iconMap[extension] || { icon: '📎', color: '#6b7280' };
        }

        function isImageFile(fileName) {
            const imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp'];
            const extension = fileName.split('.').pop().toLowerCase();
            return imageExtensions.includes(extension);
        }

        function isVideoFile(fileName) {
            const videoExtensions = ['mp4', 'avi', 'mov', 'mkv', 'webm', 'ogg'];
            const extension = fileName.split('.').pop().toLowerCase();
            return videoExtensions.includes(extension);
        }

        async function uploadFile(file, chatId) {
            if (file.size > 5 * 1024 * 1024) { // 5MB limit
                showError('File size must be less than 5MB');
                return null;
            }

            try {
                showUploadProgress();
                
                const fileName = `${Date.now()}_${file.name}`;
                const filePath = `chats/${chatId}/${fileName}`;
                const fileRef = ref(storage, filePath);
                
                // Upload with progress monitoring
                const uploadTask = uploadBytes(fileRef, file);
                
                // Monitor upload progress
                uploadTask.then((snapshot) => {
                    console.log('Upload completed');
                }).catch((error) => {
                    console.error('Upload failed:', error);
                    showError('File upload failed');
                    hideUploadProgress();
                });

                const snapshot = await uploadTask;
                const downloadURL = await getDownloadURL(snapshot.ref);
                
                hideUploadProgress();
                
                return {
                    url: downloadURL,
                    name: file.name,
                    size: file.size,
                    type: file.type,
                    path: filePath
                };
                
            } catch (error) {
                console.error('File upload error:', error);
                showError('Failed to upload file');
                hideUploadProgress();
                return null;
            }
        }

        function showUploadProgress() {
            document.getElementById('upload-progress-container').classList.remove('hidden');
            // Simulate progress for now
            let progress = 0;
            const interval = setInterval(() => {
                progress += Math.random() * 30;
                if (progress >= 95) {
                    progress = 95;
                    clearInterval(interval);
                }
                updateProgress(progress);
            }, 200);
        }

        function hideUploadProgress() {
            document.getElementById('upload-progress-container').classList.add('hidden');
            updateProgress(0);
        }

        function updateProgress(percent) {
            document.getElementById('progress-fill').style.width = `${percent}%`;
            document.getElementById('upload-percentage').textContent = `${Math.round(percent)}%`;
        }

        function openLightbox(src) {
            const lightbox = document.getElementById('lightbox');
            const content = document.getElementById('lightbox-content');
            content.src = src;
            lightbox.classList.add('active');
        }

        function closeLightbox() {
            document.getElementById('lightbox').classList.remove('active');
        }

        // Make lightbox functions globally accessible
        window.openLightbox = openLightbox;
        window.closeLightbox = closeLightbox;
        
        // Make utility functions globally accessible for message rendering
        window.getFileIcon = getFileIcon;
        window.formatFileSize = formatFileSize;
        window.formatVoiceDuration = formatVoiceDuration;
        
        // Make blocking functions globally accessible
        window.closeBlockDialog = closeBlockDialog;
        window.confirmBlockUser = confirmBlockUser;
        window.confirmUnblockUser = confirmUnblockUser;

        // Add lightbox event listeners
        document.getElementById('lightbox-close').addEventListener('click', closeLightbox);
        document.getElementById('lightbox').addEventListener('click', (e) => {
            if (e.target.id === 'lightbox') {
                closeLightbox();
            }
        });

        function createMediaMessage(fileData, isMyMessage) {
            const isImage = isImageFile(fileData.name);
            const isVideo = isVideoFile(fileData.name);
            
            if (isImage) {
                return `
                    <div class="media-message" onclick="openLightbox('${fileData.url}')">
                        <img src="${fileData.url}" alt="${fileData.name}" loading="lazy">
                        <div class="p-2 bg-white">
                            <p class="text-sm font-medium text-gray-800">${fileData.name}</p>
                            <p class="text-xs text-gray-500">${formatFileSize(fileData.size)}</p>
                        </div>
                    </div>
                `;
            } else if (isVideo) {
                return `
                    <div class="media-message">
                        <video controls preload="metadata">
                            <source src="${fileData.url}" type="${fileData.type}">
                            Your browser does not support the video tag.
                        </video>
                        <div class="p-2 bg-white">
                            <p class="text-sm font-medium text-gray-800">${fileData.name}</p>
                            <p class="text-xs text-gray-500">${formatFileSize(fileData.size)}</p>
                        </div>
                    </div>
                `;
            } else {
                const fileIcon = getFileIcon(fileData.name);
                return `
                    <div class="file-message" onclick="window.open('${fileData.url}', '_blank')">
                        <div class="file-icon" style="background-color: ${fileIcon.color}">
                            ${fileIcon.icon}
                        </div>
                        <div class="file-info">
                            <div class="file-name">${fileData.name}</div>
                            <div class="file-size">${formatFileSize(fileData.size)}</div>
                        </div>
                        <i class="fas fa-download text-gray-400"></i>
                    </div>
                `;
            }
        }

        // User Blocking Functions
        async function showUserOptionsMenu(e) {
            e.stopPropagation();
            
            // Remove any existing menu
            const existingMenu = document.querySelector('.user-options-menu');
            if (existingMenu) {
                existingMenu.remove();
                return;
            }
            
            const button = e.target.closest('button');
            const menu = document.createElement('div');
            menu.className = 'user-options-menu';
            
            // Check if user is currently blocked
            const isBlocked = await checkIfUserBlocked(currentChatUser.uid);
            
            const menuOptions = `
                ${isBlocked ? `
                    <div class="user-option unblock-option" data-action="unblock">
                        <i class="fas fa-user-check"></i>
                        <span>Unblock User</span>
                    </div>
                ` : `
                    <div class="user-option block-option" data-action="block">
                        <i class="fas fa-user-slash"></i>
                        <span>Block User</span>
                    </div>
                `}
            `;
            
            menu.innerHTML = menuOptions;
            
            // Position menu relative to button
            button.style.position = 'relative';
            button.appendChild(menu);
            
            // Add click handlers
            menu.addEventListener('click', async (e) => {
                e.stopPropagation();
                const action = e.target.closest('.user-option')?.dataset.action;
                
                if (action === 'block') {
                    showBlockDialog();
                } else if (action === 'unblock') {
                    showUnblockDialog();
                }
                
                menu.remove();
            });
            
            // Close menu when clicking outside
            setTimeout(() => {
                const closeMenu = (e) => {
                    if (!menu.contains(e.target)) {
                        menu.remove();
                        document.removeEventListener('click', closeMenu);
                        document.removeEventListener('touchstart', closeMenu);
                    }
                };
                document.addEventListener('click', closeMenu);
                document.addEventListener('touchstart', closeMenu);
            }, 100);
        }
        
        function showBlockDialog() {
            const overlay = document.createElement('div');
            overlay.className = 'block-dialog-overlay';
            
            overlay.innerHTML = `
                <div class="block-dialog">
                    <div class="dialog-header">
                        <i class="fas fa-user-slash"></i>
                        <div class="dialog-title">Block ${currentChatUser.displayName}?</div>
                    </div>
                    <div class="dialog-content">
                        Blocked users won't be able to send you messages. You can unblock them anytime.
                    </div>
                    <div class="dialog-actions">
                        <button class="dialog-btn dialog-btn-cancel" onclick="closeBlockDialog()">Cancel</button>
                        <button class="dialog-btn dialog-btn-confirm" onclick="confirmBlockUser()">Block User</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            document.body.classList.add('menu-open');
        }
        
        function showUnblockDialog() {
            const overlay = document.createElement('div');
            overlay.className = 'block-dialog-overlay';
            
            overlay.innerHTML = `
                <div class="block-dialog">
                    <div class="dialog-header">
                        <i class="fas fa-user-check" style="color: #16a34a;"></i>
                        <div class="dialog-title">Unblock ${currentChatUser.displayName}?</div>
                    </div>
                    <div class="dialog-content">
                        This user will be able to send you messages again.
                    </div>
                    <div class="dialog-actions">
                        <button class="dialog-btn dialog-btn-cancel" onclick="closeBlockDialog()">Cancel</button>
                        <button class="dialog-btn dialog-btn-unblock" onclick="confirmUnblockUser()">Unblock User</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            document.body.classList.add('menu-open');
        }
        
        function closeBlockDialog() {
            const overlay = document.querySelector('.block-dialog-overlay');
            if (overlay) {
                overlay.remove();
                document.body.classList.remove('menu-open');
            }
        }
        
        async function confirmBlockUser() {
            try {
                showLoading('Blocking user...');
                await blockUser(currentChatUser.uid);
                closeBlockDialog();
                hideLoading();
                showSuccess('User blocked successfully');
                updateChatUI();
            } catch (error) {
                console.error('Error blocking user:', error);
                hideLoading();
                showError('Failed to block user');
            }
        }
        
        async function confirmUnblockUser() {
            try {
                showLoading('Unblocking user...');
                await unblockUser(currentChatUser.uid);
                closeBlockDialog();
                hideLoading();
                showSuccess('User unblocked successfully');
                updateChatUI();
            } catch (error) {
                console.error('Error unblocking user:', error);
                hideLoading();
                showError('Failed to unblock user');
            }
        }
        
        async function blockUser(userId) {
            const blockRef = doc(db, 'users', currentUser.uid, 'blockedUsers', userId);
            await setDoc(blockRef, {
                blockedAt: serverTimestamp(),
                blockedUserId: userId,
                blockedUserName: currentChatUser.displayName
            });
        }
        
        async function unblockUser(userId) {
            const blockRef = doc(db, 'users', currentUser.uid, 'blockedUsers', userId);
            await deleteDoc(blockRef);
        }
        
        async function checkIfUserBlocked(userId) {
            try {
                const blockRef = doc(db, 'users', currentUser.uid, 'blockedUsers', userId);
                const blockDoc = await getDoc(blockRef);
                return blockDoc.exists();
            } catch (error) {
                console.error('Error checking block status:', error);
                return false;
            }
        }
        
        async function checkIfBlockedByUser(userId) {
            try {
                const blockRef = doc(db, 'users', userId, 'blockedUsers', currentUser.uid);
                const blockDoc = await getDoc(blockRef);
                return blockDoc.exists();
            } catch (error) {
                console.error('Error checking if blocked by user:', error);
                return false;
            }
        }
        
        async function updateChatUI() {
            if (!currentChatUser) return;
            
            // Check blocking status and update UI
            const isBlocked = await checkIfUserBlocked(currentChatUser.uid);
            const isBlockedByUser = await checkIfBlockedByUser(currentChatUser.uid);
            
            // Update chat status
            const statusElement = document.getElementById('chat-user-status');
            if (isBlocked) {
                statusElement.textContent = 'Blocked';
                statusElement.style.color = '#dc2626';
            } else if (isBlockedByUser) {
                statusElement.textContent = 'You are blocked';
                statusElement.style.color = '#dc2626';
            } else {
                statusElement.textContent = 'Online';
                statusElement.style.color = '#6b7280';
            }
            
            // Update message input state
            const messageInput = document.getElementById('message-input');
            const messageForm = document.getElementById('message-form');
            if (isBlockedByUser) {
                messageInput.disabled = true;
                messageInput.placeholder = 'You cannot send messages to this user';
                messageForm.style.opacity = '0.5';
                messageForm.style.pointerEvents = 'none';
            } else {
                messageInput.disabled = false;
                messageInput.placeholder = 'Type your message...';
                messageForm.style.opacity = '1';
                messageForm.style.pointerEvents = 'auto';
            }
        }

        // Message Deletion Functions
        async function deleteMessage(messageId, chatId, deleteForEveryone = false) {
            try {
                if (deleteForEveryone) {
                    // Update message to show as deleted for everyone
                    await setDoc(doc(db, 'chats', chatId, 'messages', messageId), {
                        deleted: true,
                        deletedForEveryone: true,
                        deletedBy: currentUser.uid,
                        deletedAt: serverTimestamp(),
                        originalType: 'deleted'
                    }, { merge: true });
                } else {
                    // Mark message as deleted for current user only
                    const messageRef = doc(db, 'chats', chatId, 'messages', messageId);
                    const messageDoc = await getDoc(messageRef);
                    const messageData = messageDoc.data();
                    
                    const deletedForUsers = messageData.deletedForUsers || [];
                    if (!deletedForUsers.includes(currentUser.uid)) {
                        deletedForUsers.push(currentUser.uid);
                        await setDoc(messageRef, {
                            deletedForUsers: deletedForUsers
                        }, { merge: true });
                    }
                }
            } catch (error) {
                console.error('Error deleting message:', error);
                showError('Failed to delete message');
            }
        }

        // Message Editing Functions
        function editMessage(messageId) {
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageElement) return;

            const messageContent = messageElement.querySelector('.message-content');
            const textElement = messageContent.querySelector('.message-text');
            if (!textElement) return;

            const currentText = textElement.textContent.trim();
            
            // Create edit container
            const editContainer = document.createElement('div');
            editContainer.className = 'message-edit-container';
            
            editContainer.innerHTML = `
                <div class="message-edit-input-wrapper">
                    <textarea class="message-edit-input" placeholder="Type your message...">${currentText}</textarea>
                    <div class="message-edit-actions">
                        <button class="edit-cancel-btn">
                            <i class="fas fa-times"></i>
                            Cancel
                        </button>
                        <button class="edit-save-btn">
                            <i class="fas fa-check"></i>
                            Save
                        </button>
                    </div>
                </div>
            `;

            // Replace message content with edit container
            messageContent.style.display = 'none';
            messageElement.appendChild(editContainer);

            // Focus and select all text
            const textarea = editContainer.querySelector('.message-edit-input');
            textarea.focus();
            textarea.select();

            // Auto-resize textarea
            const autoResize = () => {
                textarea.style.height = 'auto';
                textarea.style.height = textarea.scrollHeight + 'px';
            };
            textarea.addEventListener('input', autoResize);
            autoResize();

            // Handle cancel
            editContainer.querySelector('.edit-cancel-btn').addEventListener('click', () => {
                cancelEdit(messageElement, editContainer);
            });

            // Handle save
            editContainer.querySelector('.edit-save-btn').addEventListener('click', () => {
                const newText = textarea.value.trim();
                if (newText && newText !== currentText) {
                    saveEditedMessage(messageId, newText, currentText, messageElement, editContainer);
                } else {
                    cancelEdit(messageElement, editContainer);
                }
            });

            // Handle Enter to save (Shift+Enter for new line)
            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    const newText = textarea.value.trim();
                    if (newText && newText !== currentText) {
                        saveEditedMessage(messageId, newText, currentText, messageElement, editContainer);
                    }
                }
                if (e.key === 'Escape') {
                    cancelEdit(messageElement, editContainer);
                }
            });
        }

        function cancelEdit(messageElement, editContainer) {
            const messageContent = messageElement.querySelector('.message-content');
            messageContent.style.display = '';
            editContainer.remove();
        }

        async function saveEditedMessage(messageId, newText, originalText, messageElement, editContainer) {
            try {
                const chatId = getCurrentChatId();
                if (!chatId) return;

                const messageRef = doc(db, 'chats', chatId, 'messages', messageId);
                const messageDoc = await getDoc(messageRef);
                const messageData = messageDoc.data();

                // Create edit history entry
                const editHistory = messageData.editHistory || [];
                editHistory.push({
                    text: originalText,
                    editedAt: serverTimestamp(),
                    editedBy: currentUser.uid
                });

                // Update message with new text and edit history
                await setDoc(messageRef, {
                    text: newText,
                    edited: true,
                    editedAt: serverTimestamp(),
                    editHistory: editHistory
                }, { merge: true });

                // Update UI immediately
                const messageContent = messageElement.querySelector('.message-content');
                const textElement = messageContent.querySelector('.message-text');
                textElement.textContent = newText;
                
                // Add edited indicator if not already present
                if (!messageElement.querySelector('.edit-indicator')) {
                    const editIndicator = document.createElement('span');
                    editIndicator.className = 'edit-indicator';
                    editIndicator.innerHTML = '<i class="fas fa-edit"></i> edited';
                    editIndicator.addEventListener('click', () => showEditHistory(messageId));
                    
                    const timestamp = messageElement.querySelector('.message-timestamp');
                    if (timestamp) {
                        timestamp.parentNode.insertBefore(editIndicator, timestamp);
                    }
                }

                cancelEdit(messageElement, editContainer);
                
            } catch (error) {
                console.error('Error saving edited message:', error);
                showError('Failed to save changes');
            }
        }

        function showEditHistory(messageId) {
            // Get message data to show edit history
            const chatId = getCurrentChatId();
            if (!chatId) return;

            const messageRef = doc(db, 'chats', chatId, 'messages', messageId);
            getDoc(messageRef).then(messageDoc => {
                const messageData = messageDoc.data();
                const editHistory = messageData.editHistory || [];
                
                if (editHistory.length === 0) {
                    showError('No edit history available');
                    return;
                }

                // Create modal
                const modal = document.createElement('div');
                modal.className = 'edit-history-modal';
                modal.innerHTML = `
                    <div class="edit-history-content">
                        <div class="edit-history-header">
                            <h3>Edit History</h3>
                            <button class="close-edit-history">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        <div class="edit-history-list">
                            <div class="edit-history-item current">
                                <div class="edit-history-label">Current</div>
                                <div class="edit-history-text">${messageData.text}</div>
                                <div class="edit-history-time">${formatTimestamp(messageData.editedAt || messageData.timestamp)}</div>
                            </div>
                            ${editHistory.map((edit, index) => `
                                <div class="edit-history-item">
                                    <div class="edit-history-label">Version ${editHistory.length - index}</div>
                                    <div class="edit-history-text">${edit.text}</div>
                                    <div class="edit-history-time">${formatTimestamp(edit.editedAt)}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                // Close modal handlers
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });

                modal.querySelector('.close-edit-history').addEventListener('click', () => {
                    modal.remove();
                });

                // ESC key to close
                const handleEsc = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', handleEsc);
                    }
                };
                document.addEventListener('keydown', handleEsc);

            }).catch(error => {
                console.error('Error loading edit history:', error);
                showError('Failed to load edit history');
            });
        }

        // Message Forwarding Functions
        async function forwardMessage(messageId) {
            try {
                const chatId = getCurrentChatId();
                if (!chatId) return;

                const messageRef = doc(db, 'chats', chatId, 'messages', messageId);
                const messageDoc = await getDoc(messageRef);
                const messageData = messageDoc.data();

                if (!messageData || messageData.deleted) {
                    showError('Message not found or has been deleted');
                    return;
                }

                showForwardModal(messageData);
            } catch (error) {
                console.error('Error preparing forward message:', error);
                showError('Failed to forward message');
            }
        }

        async function showForwardModal(messageData) {
            // Get list of contacts (users that the current user has chatted with)
            const contacts = await getUserContacts();
            
            const modal = document.createElement('div');
            modal.className = 'forward-modal';
            
            // Create message preview
            let messagePreview = '';
            if (messageData.text) {
                messagePreview = messageData.text.length > 100 ? 
                    messageData.text.substring(0, 100) + '...' : 
                    messageData.text;
            } else if (messageData.fileUrl) {
                messagePreview = `📎 ${messageData.fileName || 'File attachment'}`;
            } else if (messageData.imageUrl) {
                messagePreview = '🖼️ Image';
            } else if (messageData.voiceUrl) {
                messagePreview = '🎵 Voice message';
            }

            modal.innerHTML = `
                <div class="forward-modal-content">
                    <div class="forward-modal-header">
                        <h3>Forward Message</h3>
                        <button class="close-forward-modal">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    
                    <div class="forward-message-preview">
                        <div class="forward-message-preview-label">Message to forward</div>
                        <div class="forward-message-preview-content">${messagePreview}</div>
                    </div>
                    
                    <div class="forward-search-container">
                        <input type="text" class="forward-search-input" placeholder="Search contacts...">
                    </div>
                    
                    <div class="forward-contacts-list" id="forward-contacts-list">
                        ${contacts.map(contact => `
                            <div class="forward-contact-item" data-user-id="${contact.uid}">
                                <input type="checkbox" class="forward-contact-checkbox" id="contact-${contact.uid}">
                                <div class="forward-contact-avatar">
                                    ${contact.displayName ? contact.displayName.charAt(0).toUpperCase() : '?'}
                                </div>
                                <div class="forward-contact-info">
                                    <div class="forward-contact-name">${contact.displayName || 'Unknown User'}</div>
                                    <div class="forward-contact-status">@${contact.username || contact.email}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div class="forward-modal-footer">
                        <div class="forward-selected-count">0 selected</div>
                        <div class="forward-actions">
                            <button class="forward-cancel-btn">Cancel</button>
                            <button class="forward-send-btn" disabled>
                                <i class="fas fa-paper-plane"></i>
                                Forward
                            </button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Handle contact selection
            const selectedContacts = new Set();
            const contactsList = modal.querySelector('#forward-contacts-list');
            const selectedCountEl = modal.querySelector('.forward-selected-count');
            const forwardBtn = modal.querySelector('.forward-send-btn');

            contactsList.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const userId = e.target.closest('.forward-contact-item').dataset.userId;
                    if (e.target.checked) {
                        selectedContacts.add(userId);
                        e.target.closest('.forward-contact-item').classList.add('selected');
                    } else {
                        selectedContacts.delete(userId);
                        e.target.closest('.forward-contact-item').classList.remove('selected');
                    }
                    
                    selectedCountEl.textContent = `${selectedContacts.size} selected`;
                    forwardBtn.disabled = selectedContacts.size === 0;
                }
            });

            // Handle contact item click (toggle checkbox)
            contactsList.addEventListener('click', (e) => {
                const contactItem = e.target.closest('.forward-contact-item');
                if (contactItem && !e.target.matches('input[type="checkbox"]')) {
                    const checkbox = contactItem.querySelector('.forward-contact-checkbox');
                    checkbox.checked = !checkbox.checked;
                    checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                }
            });

            // Handle search
            const searchInput = modal.querySelector('.forward-search-input');
            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                const contactItems = modal.querySelectorAll('.forward-contact-item');
                
                contactItems.forEach(item => {
                    const name = item.querySelector('.forward-contact-name').textContent.toLowerCase();
                    const status = item.querySelector('.forward-contact-status').textContent.toLowerCase();
                    const matches = name.includes(searchTerm) || status.includes(searchTerm);
                    item.style.display = matches ? '' : 'none';
                });
            });

            // Handle forward button
            forwardBtn.addEventListener('click', async () => {
                await sendForwardedMessage(messageData, Array.from(selectedContacts));
                modal.remove();
            });

            // Close modal handlers
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });

            modal.querySelector('.close-forward-modal').addEventListener('click', () => {
                modal.remove();
            });

            modal.querySelector('.forward-cancel-btn').addEventListener('click', () => {
                modal.remove();
            });

            // ESC key to close
            const handleEsc = (e) => {
                if (e.key === 'Escape') {
                    modal.remove();
                    document.removeEventListener('keydown', handleEsc);
                }
            };
            document.addEventListener('keydown', handleEsc);
        }

        async function getUserContacts() {
            try {
                // Get all chats the user is part of
                const chatsQuery = query(
                    collection(db, 'chats'),
                    where('participants', 'array-contains', currentUser.uid)
                );
                
                const chatsSnapshot = await getDocs(chatsQuery);
                const contacts = [];
                const uniqueUsers = new Set();

                // Extract other participants from chats
                for (const chatDoc of chatsSnapshot.docs) {
                    const chatData = chatDoc.data();
                    const otherParticipants = chatData.participants.filter(uid => uid !== currentUser.uid);
                    
                    for (const participantId of otherParticipants) {
                        if (!uniqueUsers.has(participantId)) {
                            uniqueUsers.add(participantId);
                            
                            // Get user details
                            const userDoc = await getDoc(doc(db, 'users', participantId));
                            if (userDoc.exists()) {
                                contacts.push({
                                    uid: participantId,
                                    ...userDoc.data()
                                });
                            }
                        }
                    }
                }

                return contacts;
            } catch (error) {
                console.error('Error getting user contacts:', error);
                return [];
            }
        }

        async function sendForwardedMessage(originalMessage, recipientIds) {
            try {
                for (const recipientId of recipientIds) {
                    const chatId = generateChatId(currentUser.uid, recipientId);
                    
                    // Create forwarded message
                    const forwardedMessage = {
                        senderId: currentUser.uid,
                        recipientId: recipientId,
                        timestamp: serverTimestamp(),
                        forwarded: true,
                        originalSender: originalMessage.senderId,
                        forwardedBy: currentUser.uid,
                        forwardedAt: serverTimestamp()
                    };

                    // Copy original message content
                    if (originalMessage.text) {
                        forwardedMessage.text = originalMessage.text;
                        forwardedMessage.type = 'text';
                        // For text messages, we need to copy the encrypted content
                        if (originalMessage.ciphertext && originalMessage.iv) {
                            forwardedMessage.ciphertext = originalMessage.ciphertext;
                            forwardedMessage.iv = originalMessage.iv;
                        }
                    } else if (originalMessage.imageUrl) {
                        forwardedMessage.imageUrl = originalMessage.imageUrl;
                        forwardedMessage.type = 'image';
                    } else if (originalMessage.fileUrl) {
                        forwardedMessage.fileUrl = originalMessage.fileUrl;
                        forwardedMessage.fileName = originalMessage.fileName;
                        forwardedMessage.fileSize = originalMessage.fileSize;
                        forwardedMessage.type = 'file';
                    } else if (originalMessage.voiceUrl) {
                        forwardedMessage.voiceUrl = originalMessage.voiceUrl;
                        forwardedMessage.voiceDuration = originalMessage.voiceDuration;
                        forwardedMessage.type = 'voice';
                    }

                    // Add to messages collection
                    await addDoc(collection(db, 'chats', chatId, 'messages'), forwardedMessage);
                    
                    // Update chat metadata
                    await updateChatMetadata(recipientId, { 
                        text: `Forwarded message`, 
                        iv: null 
                    });
                }

                showSuccess(`Message forwarded to ${recipientIds.length} contact${recipientIds.length > 1 ? 's' : ''}`);
            } catch (error) {
                console.error('Error forwarding message:', error);
                showError('Failed to forward message');
            }
        }

        // Message Reply Functions
        let currentReplyingTo = null;

        async function replyToMessage(messageId) {
            try {
                const chatId = getCurrentChatId();
                if (!chatId) return;

                const messageRef = doc(db, 'chats', chatId, 'messages', messageId);
                const messageDoc = await getDoc(messageRef);
                const messageData = messageDoc.data();

                if (!messageData || messageData.deleted) {
                    showError('Message not found or has been deleted');
                    return;
                }

                showReplyPreview(messageData);
            } catch (error) {
                console.error('Error preparing reply:', error);
                showError('Failed to reply to message');
            }
        }

        async function showReplyPreview(messageData) {
            // Remove any existing reply preview
            clearReplyPreview();
            
            currentReplyingTo = messageData;

            // Get the message input container
            const messageInputContainer = document.querySelector('.message-input-container');
            if (!messageInputContainer) return;

            // Add replying class
            messageInputContainer.classList.add('replying');

            // Create reply preview
            const replyPreview = document.createElement('div');
            replyPreview.className = 'reply-preview-container';
            replyPreview.id = 'reply-preview';

            // Get reply content based on message type
            let replyContent = '';
            let authorName = '';

            // Get author name
            if (messageData.senderId === currentUser.uid) {
                authorName = 'You';
            } else if (currentChatUser) {
                authorName = currentChatUser.displayName || currentChatUser.username || 'Unknown User';
            }

            // Get content based on message type
            if (messageData.text || messageData.ciphertext) {
                if (messageData.ciphertext) {
                    try {
                        const decrypted = await safeDecryptMessage(messageData);
                        replyContent = decrypted;
                    } catch (error) {
                        replyContent = 'Encrypted message';
                    }
                } else {
                    replyContent = messageData.text;
                }
            } else if (messageData.type === 'image' || messageData.imageUrl) {
                replyContent = '<span class="reply-preview-media">📷 Image</span>';
            } else if (messageData.type === 'file' || messageData.fileUrl) {
                const fileName = messageData.fileName || 'File';
                replyContent = `<span class="reply-preview-media">📎 ${fileName}</span>`;
            } else if (messageData.type === 'voice' || messageData.voiceUrl) {
                replyContent = '<span class="reply-preview-media">🎵 Voice message</span>';
            } else {
                replyContent = 'Message';
            }

            replyPreview.innerHTML = `
                <div class="reply-preview-header">
                    <div class="reply-preview-author">${authorName}</div>
                    <button class="reply-preview-close" onclick="clearReplyPreview()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="reply-preview-content">${replyContent}</div>
            `;

            // Insert before the input area
            messageInputContainer.insertBefore(replyPreview, messageInputContainer.firstChild);

            // Focus the message input
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                messageInput.focus();
            }
        }

        function clearReplyPreview() {
            currentReplyingTo = null;
            
            const replyPreview = document.getElementById('reply-preview');
            if (replyPreview) {
                replyPreview.remove();
            }

            const messageInputContainer = document.querySelector('.message-input-container');
            if (messageInputContainer) {
                messageInputContainer.classList.remove('replying');
            }
        }

        // Make clearReplyPreview available globally
        window.clearReplyPreview = clearReplyPreview;

        // Message Search Functions
        let searchResults = [];
        let currentSearchTerm = '';

        function openMessageSearch() {
            const searchContainer = document.getElementById('message-search-container');
            const searchInput = document.getElementById('message-search-input');
            
            searchContainer.classList.add('active');
            
            // Focus the search input
            setTimeout(() => {
                searchInput.focus();
            }, 300);
        }

        function closeMessageSearch() {
            const searchContainer = document.getElementById('message-search-container');
            searchContainer.classList.remove('active');
            clearMessageSearch();
        }

        function clearMessageSearch() {
            const searchInput = document.getElementById('message-search-input');
            const clearBtn = document.querySelector('.message-search-clear-btn');
            const statusEl = document.getElementById('message-search-status');
            const resultsEl = document.getElementById('message-search-results-list');
            
            searchInput.value = '';
            clearBtn.classList.remove('visible');
            statusEl.textContent = 'Type to search through your conversation';
            resultsEl.innerHTML = '';
            searchResults = [];
            currentSearchTerm = '';
        }

        async function searchMessages(searchTerm) {
            if (!searchTerm.trim() || !currentChatUser) {
                clearMessageSearch();
                return;
            }

            currentSearchTerm = searchTerm.toLowerCase();
            const chatId = getCurrentChatId();
            if (!chatId) return;

            try {
                const statusEl = document.getElementById('message-search-status');
                statusEl.textContent = 'Searching...';

                // Get all messages for the current chat
                const messagesRef = collection(db, 'chats', chatId, 'messages');
                const q = query(messagesRef, orderBy('timestamp', 'desc'));
                const snapshot = await getDocs(q);

                const results = [];
                
                for (const docData of snapshot.docs) {
                    const messageData = { id: docData.id, ...docData.data() };
                    
                    // Skip deleted messages
                    if (messageData.deleted) continue;
                    
                    let searchableText = '';
                    let messageType = 'text';
                    
                    // Extract searchable text based on message type
                    if (messageData.text) {
                        searchableText = messageData.text;
                    } else if (messageData.ciphertext) {
                        try {
                            const decrypted = await safeDecryptMessage(messageData);
                            searchableText = decrypted;
                        } catch (error) {
                            continue; // Skip if can't decrypt
                        }
                    } else if (messageData.fileName) {
                        searchableText = messageData.fileName;
                        messageType = 'file';
                    } else {
                        continue; // Skip non-text messages
                    }

                    // Check if search term matches
                    if (searchableText.toLowerCase().includes(currentSearchTerm)) {
                        results.push({
                            ...messageData,
                            searchableText,
                            messageType
                        });
                    }
                }

                searchResults = results;
                displayMessageSearchResults(results);

            } catch (error) {
                console.error('Error searching messages:', error);
                const statusEl = document.getElementById('message-search-status');
                statusEl.textContent = 'Error searching messages';
            }
        }

        function displayMessageSearchResults(results) {
            const statusEl = document.getElementById('message-search-status');
            const resultsEl = document.getElementById('message-search-results-list');

            if (results.length === 0) {
                statusEl.textContent = `No messages found for "${currentSearchTerm}"`;
                resultsEl.innerHTML = '';
                return;
            }

            statusEl.textContent = `${results.length} message${results.length === 1 ? '' : 's'} found`;
            
            resultsEl.innerHTML = results.map(message => {
                const isMyMessage = message.senderId === currentUser.uid;
                const senderName = isMyMessage ? 'You' : (currentChatUser.displayName || currentChatUser.username || 'Unknown');
                
                // Highlight search term in content
                const highlightedText = highlightSearchTerm(message.searchableText, currentSearchTerm);
                
                // Format timestamp
                const messageDate = message.timestamp ? new Date(message.timestamp.toDate()) : new Date();
                const timeString = formatTimestamp(message.timestamp);
                
                return `
                    <div class="message-search-result" onclick="scrollToMessage('${message.id}')">
                        <div class="message-search-result-header">
                            <div class="message-search-result-sender">${senderName}</div>
                            <div class="message-search-result-time">${timeString}</div>
                        </div>
                        <div class="message-search-result-content">
                            ${message.messageType === 'file' ? '📎 ' : ''}${highlightedText}
                        </div>
                        ${message.replyTo ? `<div class="message-search-result-context">Reply to: ${message.replyTo.senderName}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        function highlightSearchTerm(text, searchTerm) {
            if (!searchTerm) return text;
            
            const regex = new RegExp(`(${escapeRegExp(searchTerm)})`, 'gi');
            return text.replace(regex, '<span class="message-search-result-highlight">$1</span>');
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function scrollToMessage(messageId) {
            closeMessageSearch();
            
            // Find the message element
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageElement) {
                // Scroll to the message
                messageElement.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
                
                // Highlight the message temporarily
                messageElement.classList.add('search-highlight');
                setTimeout(() => {
                    messageElement.classList.remove('search-highlight');
                }, 2000);
            }
        }

        // Make search functions globally available
        window.openMessageSearch = openMessageSearch;
        window.closeMessageSearch = closeMessageSearch;
        window.clearMessageSearch = clearMessageSearch;

        // Message Pinning Functions
        let pinnedMessages = [];

        async function togglePinMessage(messageId) {
            try {
                const chatId = getCurrentChatId();
                if (!chatId) return;

                const messageRef = doc(db, 'chats', chatId, 'messages', messageId);
                const messageDoc = await getDoc(messageRef);
                const messageData = messageDoc.data();

                if (!messageData || messageData.deleted) {
                    showError('Message not found or has been deleted');
                    return;
                }

                const isPinned = messageData.pinned;
                
                if (isPinned) {
                    // Unpin the message
                    await setDoc(messageRef, {
                        pinned: false,
                        pinnedAt: null,
                        pinnedBy: null
                    }, { merge: true });
                    showSuccess('Message unpinned');
                } else {
                    // Pin the message
                    await setDoc(messageRef, {
                        pinned: true,
                        pinnedAt: serverTimestamp(),
                        pinnedBy: currentUser.uid
                    }, { merge: true });
                    showSuccess('Message pinned');
                }

                // Update pinned messages display
                loadPinnedMessages();

            } catch (error) {
                console.error('Error toggling pin:', error);
                showError('Failed to pin/unpin message');
            }
        }

        async function loadPinnedMessages() {
            if (!currentChatUser) return;

            try {
                const chatId = getCurrentChatId();
                if (!chatId) return;

                const messagesRef = collection(db, 'chats', chatId, 'messages');
                const q = query(
                    messagesRef, 
                    where('pinned', '==', true),
                    orderBy('pinnedAt', 'desc')
                );
                
                const snapshot = await getDocs(q);
                pinnedMessages = [];
                
                for (const docData of snapshot.docs) {
                    const messageData = { id: docData.id, ...docData.data() };
                    
                    // Skip deleted messages
                    if (messageData.deleted) continue;
                    
                    pinnedMessages.push(messageData);
                }

                displayPinnedMessages();

            } catch (error) {
                console.error('Error loading pinned messages:', error);
            }
        }

        async function displayPinnedMessages() {
            const container = document.getElementById('pinned-messages-container');
            const listEl = document.getElementById('pinned-messages-list');

            if (pinnedMessages.length === 0) {
                container.classList.remove('has-pins');
                return;
            }

            container.classList.add('has-pins');
            
            const pinnedHTML = [];
            
            for (const message of pinnedMessages) {
                const isMyMessage = message.senderId === currentUser.uid;
                const senderName = isMyMessage ? 'You' : (currentChatUser.displayName || currentChatUser.username || 'Unknown');
                
                let content = '';
                
                // Get message content
                if (message.text) {
                    content = message.text;
                } else if (message.ciphertext) {
                    try {
                        content = await safeDecryptMessage(message);
                    } catch (error) {
                        content = 'Encrypted message';
                    }
                } else if (message.fileName) {
                    content = `<span class="pinned-message-media">📎 ${message.fileName}</span>`;
                } else if (message.type === 'image') {
                    content = '<span class="pinned-message-media">📷 Image</span>';
                } else if (message.type === 'voice') {
                    content = '<span class="pinned-message-media">🎵 Voice message</span>';
                } else {
                    content = 'Message';
                }
                
                // Format timestamp
                const timeString = formatTimestamp(message.timestamp);
                
                pinnedHTML.push(`
                    <div class="pinned-message-item" onclick="scrollToMessage('${message.id}')" data-message-id="${message.id}">
                        <div class="pinned-message-header">
                            <div class="pinned-message-sender">${senderName}</div>
                            <div class="pinned-message-time">${timeString}</div>
                        </div>
                        <div class="pinned-message-content">${content}</div>
                        <div class="pin-indicator">
                            <i class="fas fa-thumbtack"></i>
                        </div>
                    </div>
                `);
            }
            
            listEl.innerHTML = pinnedHTML.join('');
        }

        function togglePinnedMessages() {
            const container = document.getElementById('pinned-messages-container');
            const icon = document.getElementById('pinned-toggle-icon');
            
            container.classList.toggle('pinned-messages-collapsed');
            
            if (container.classList.contains('pinned-messages-collapsed')) {
                icon.className = 'fas fa-chevron-down';
            } else {
                icon.className = 'fas fa-chevron-up';
            }
        }

        // Make pinning functions globally available
        window.togglePinnedMessages = togglePinnedMessages;

        async function showMessageMenu(messageElement, messageId, chatId, isMyMessage) {
            // Remove any existing menus or pickers
            const existingMenu = document.querySelector('.message-menu');
            const existingPicker = document.querySelector('.emoji-picker');
            if (existingMenu) {
                existingMenu.remove();
            }
            if (existingPicker) {
                existingPicker.remove();
            }

            const menu = document.createElement('div');
            menu.className = 'message-menu';
            
            const messageContainer = messageElement.closest('.message-container');
            const rect = messageContainer.getBoundingClientRect();
            
            // Mobile vs Desktop positioning
            const isMobile = window.innerWidth <= 768;
            
            if (!isMobile) {
                // Desktop positioning
                if (isMyMessage) {
                    menu.style.right = '10px';
                } else {
                    menu.style.left = '10px';
                }
                menu.style.top = `${rect.top + window.scrollY}px`;
            }
            // Mobile positioning is handled by CSS

            let menuOptions = '';
            
            if (isMyMessage) {
                // Get message element to check if it's a text message and not deleted
                const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                const messageContent = messageElement?.querySelector('.message-content');
                const isTextMessage = messageContent && !messageContent.querySelector('.file-attachment, .image-container, .voice-message');
                const isDeleted = messageElement?.classList.contains('deleted-message');
                
                // Check if message is pinned
                const chatId = getCurrentChatId();
                let isPinned = false;
                if (chatId) {
                    try {
                        const messageRef = doc(db, 'chats', chatId, 'messages', messageId);
                        const messageDoc = await getDoc(messageRef);
                        const messageData = messageDoc.data();
                        isPinned = messageData?.pinned || false;
                    } catch (error) {
                        console.log('Error checking pin status:', error);
                    }
                }
                
                menuOptions = `
                    ${isTextMessage && !isDeleted ? `
                        <div class="menu-option edit-message" data-action="edit">
                            <i class="fas fa-edit"></i>
                            <span>Edit</span>
                        </div>
                    ` : ''}
                    ${!isDeleted ? `
                        <div class="menu-option forward-message" data-action="forward">
                            <i class="fas fa-share"></i>
                            <span>Forward</span>
                        </div>
                        <div class="menu-option reply-message" data-action="reply">
                            <i class="fas fa-reply"></i>
                            <span>Reply</span>
                        </div>
                        <div class="menu-option pin-message" data-action="pin">
                            <i class="fas fa-thumbtack"></i>
                            <span>${isPinned ? 'Unpin' : 'Pin'}</span>
                        </div>
                    ` : ''}
                    <div class="menu-option delete-for-everyone" data-action="delete-everyone">
                        <i class="fas fa-trash"></i>
                        <span>Delete for Everyone</span>
                    </div>
                    <div class="menu-option delete-for-me" data-action="delete-me">
                        <i class="fas fa-trash-alt"></i>
                        <span>Delete for Me</span>
                    </div>
                `;
            } else {
                // Get message element to check if it's deleted
                const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                const isDeleted = messageElement?.classList.contains('deleted-message');
                
                // Check if message is pinned
                let isPinned = false;
                try {
                    const messageRef = doc(db, 'chats', chatId, 'messages', messageId);
                    const messageDoc = await getDoc(messageRef);
                    const messageData = messageDoc.data();
                    isPinned = messageData?.pinned || false;
                } catch (error) {
                    console.log('Error checking pin status:', error);
                }
                
                menuOptions = `
                    ${!isDeleted ? `
                        <div class="menu-option forward-message" data-action="forward">
                            <i class="fas fa-share"></i>
                            <span>Forward</span>
                        </div>
                        <div class="menu-option reply-message" data-action="reply">
                            <i class="fas fa-reply"></i>
                            <span>Reply</span>
                        </div>
                        <div class="menu-option pin-message" data-action="pin">
                            <i class="fas fa-thumbtack"></i>
                            <span>${isPinned ? 'Unpin' : 'Pin'}</span>
                        </div>
                    ` : ''}
                    <div class="menu-option delete-for-me" data-action="delete-me">
                        <i class="fas fa-trash-alt text-gray-500"></i>
                        <span>Delete for Me</span>
                    </div>
                `;
            }

            menu.innerHTML = menuOptions;

            // Add click handlers
            menu.addEventListener('click', async (e) => {
                e.stopPropagation();
                const action = e.target.closest('.menu-option')?.dataset.action;
                
                if (action === 'edit') {
                    editMessage(messageId);
                } else if (action === 'forward') {
                    forwardMessage(messageId);
                } else if (action === 'reply') {
                    replyToMessage(messageId);
                } else if (action === 'pin') {
                    togglePinMessage(messageId);
                } else if (action === 'delete-everyone') {
                    if (confirm('Delete this message for everyone? This cannot be undone.')) {
                        await deleteMessage(messageId, chatId, true);
                    }
                } else if (action === 'delete-me') {
                    await deleteMessage(messageId, chatId, false);
                }
                
                menu.remove();
                document.body.classList.remove('menu-open');
            });

            // Prevent menu from closing when touching it
            menu.addEventListener('touchstart', (e) => {
                e.stopPropagation();
            });

            document.body.appendChild(menu);

            // Add body class for mobile to prevent scrolling
            if (window.innerWidth <= 768) {
                document.body.classList.add('menu-open');
            }

            // Close menu when clicking/touching outside
            const closeMenu = (e) => {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.body.classList.remove('menu-open');
                    document.removeEventListener('click', closeMenu);
                    document.removeEventListener('touchstart', closeMenu);
                }
            };

            setTimeout(() => {
                document.addEventListener('click', closeMenu);
                document.addEventListener('touchstart', closeMenu);
            }, 100);
        }

        // Reaction functions
        async function addReaction(messageId, emoji, chatId) {
            try {
                // First, remove any existing reaction from this user on this message
                await removeUserReactions(messageId, chatId);
                
                // Then add the new reaction
                const reactionId = `${messageId}_${currentUser.uid}_${emoji}`;
                await setDoc(doc(db, 'chats', chatId, 'reactions', reactionId), {
                    messageId: messageId,
                    userId: currentUser.uid,
                    userName: currentUser.displayName,
                    emoji: emoji,
                    timestamp: serverTimestamp()
                });
            } catch (error) {
                console.error('Error adding reaction:', error);
            }
        }

        async function removeReaction(messageId, emoji, chatId) {
            try {
                const reactionId = `${messageId}_${currentUser.uid}_${emoji}`;
                await deleteDoc(doc(db, 'chats', chatId, 'reactions', reactionId));
            } catch (error) {
                console.error('Error removing reaction:', error);
            }
        }

        async function removeUserReactions(messageId, chatId) {
            try {
                const reactionsRef = collection(db, 'chats', chatId, 'reactions');
                const q = query(reactionsRef, 
                    where('messageId', '==', messageId),
                    where('userId', '==', currentUser.uid)
                );
                const snapshot = await getDocs(q);
                
                // Remove all existing reactions from this user on this message
                const deletePromises = [];
                snapshot.forEach(doc => {
                    deletePromises.push(deleteDoc(doc.ref));
                });
                
                await Promise.all(deletePromises);
            } catch (error) {
                console.error('Error removing user reactions:', error);
            }
        }

        function showEmojiPicker(messageElement, messageId, chatId) {
            // Remove any existing pickers or menus
            const existingPicker = document.querySelector('.emoji-picker');
            const existingMenu = document.querySelector('.message-menu');
            if (existingPicker) {
                existingPicker.remove();
            }
            if (existingMenu) {
                existingMenu.remove();
            }

            const picker = document.createElement('div');
            picker.className = 'emoji-picker';
            
            const messageContainer = messageElement.closest('.message-container');
            const isMyMessage = messageContainer.classList.contains('my-message-container');
            
            // Mobile vs Desktop positioning
            const isMobile = window.innerWidth <= 768;
            
            if (!isMobile) {
                // Desktop positioning
                if (isMyMessage) {
                    picker.style.right = '45px';
                    picker.style.top = '50%';
                    picker.style.transform = 'translateY(-50%)';
                } else {
                    picker.style.left = '45px';
                    picker.style.top = '50%';
                    picker.style.transform = 'translateY(-50%)';
                }
                messageContainer.appendChild(picker);
            } else {
                // Mobile positioning is handled by CSS - append to body
                document.body.appendChild(picker);
                document.body.classList.add('menu-open');
            }

            commonEmojis.forEach(emoji => {
                const emojiBtn = document.createElement('div');
                emojiBtn.className = 'emoji-option';
                emojiBtn.textContent = emoji;
                emojiBtn.onclick = async (e) => {
                    e.stopPropagation();
                    await addReaction(messageId, emoji, chatId);
                    picker.remove();
                    document.body.classList.remove('menu-open');
                };
                picker.appendChild(emojiBtn);
            });

            // Prevent picker from closing when touching it
            picker.addEventListener('touchstart', (e) => {
                e.stopPropagation();
            });

            // Close picker when clicking/touching outside
            const closePicker = (e) => {
                if (!picker.contains(e.target)) {
                    picker.remove();
                    document.body.classList.remove('menu-open');
                    document.removeEventListener('click', closePicker);
                    document.removeEventListener('touchstart', closePicker);
                }
            };

            setTimeout(() => {
                document.addEventListener('click', closePicker);
                document.addEventListener('touchstart', closePicker);
            }, 100);
        }

        function createReactionButton(messageElement, messageId, chatId) {
            const reactionBtn = document.createElement('div');
            reactionBtn.className = 'reaction-btn';
            reactionBtn.innerHTML = '<i class="far fa-smile text-gray-600"></i>';
            reactionBtn.onclick = (e) => {
                e.stopPropagation();
                showEmojiPicker(messageElement, messageId, chatId);
            };
            return reactionBtn;
        }

        function renderReactions(reactionsData, messageId, chatId, reactionsContainer) {
            reactionsContainer.innerHTML = '';
            
            const reactionGroups = {};
            Object.values(reactionsData).forEach(reaction => {
                if (!reactionGroups[reaction.emoji]) {
                    reactionGroups[reaction.emoji] = [];
                }
                reactionGroups[reaction.emoji].push(reaction);
            });

            Object.entries(reactionGroups).forEach(([emoji, reactions]) => {
                const reactionItem = document.createElement('div');
                reactionItem.className = 'reaction-item';
                
                const hasMyReaction = reactions.some(r => r.userId === currentUser.uid);
                if (hasMyReaction) {
                    reactionItem.classList.add('my-reaction');
                }

                const count = reactions.length;
                reactionItem.innerHTML = `
                    <span>${emoji}</span>
                    ${count > 1 ? `<span class="reaction-count">${count}</span>` : ''}
                `;

                const userNames = reactions.map(r => r.userName).join(', ');
                reactionItem.title = userNames;

                reactionItem.onclick = async (e) => {
                    e.stopPropagation();
                    if (hasMyReaction) {
                        await removeReaction(messageId, emoji, chatId);
                    } else {
                        await addReaction(messageId, emoji, chatId);
                    }
                };

                reactionsContainer.appendChild(reactionItem);
            });
        }

        // Authentication functions
        async function handleSignup(event) {
            event.preventDefault();
            
            const name = document.getElementById('signup-name').value.trim();
            const username = document.getElementById('signup-username').value.trim().toLowerCase();
            const email = document.getElementById('signup-email').value.trim();
            const password = document.getElementById('signup-password').value;

            if (!name || !username || !email || !password) {
                showError('Please fill in all fields');
                return;
            }

            if (!/^[a-zA-Z0-9_]{3,20}$/.test(username)) {
                showError('Username must be 3-20 characters and contain only letters, numbers, and underscores');
                return;
            }

            showLoading('Creating your secure account...');

            try {
                const usernameQuery = query(
                    collection(db, 'users'), 
                    where('username', '==', username),
                    limit(1)
                );
                const usernameSnapshot = await getDocs(usernameQuery);
                
                if (!usernameSnapshot.empty) {
                    throw new Error('Username is already taken');
                }

                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                const user = userCredential.user;

                await updateProfile(user, { displayName: name });

                await setDoc(doc(db, 'users', user.uid), {
                    uid: user.uid,
                    email: email,
                    displayName: name,
                    username: username,
                    createdAt: serverTimestamp(),
                    lastSeen: serverTimestamp(),
                    online: true
                });

                console.log('User created successfully');
                
            } catch (error) {
                console.error('Signup error:', error);
                showError(error.message);
            } finally {
                hideLoading();
            }
        }

        async function handleLogin(event) {
            event.preventDefault();
            
            const email = document.getElementById('login-email').value.trim();
            const password = document.getElementById('login-password').value;

            if (!email || !password) {
                showError('Please fill in all fields');
                return;
            }

            showLoading('Signing you in securely...');

            try {
                await signInWithEmailAndPassword(auth, email, password);
                console.log('User signed in successfully');
            } catch (error) {
                console.error('Login error:', error);
                showError(error.message);
            } finally {
                hideLoading();
            }
        }

        async function handleLogout() {
            showLoading('Signing you out...');
            
            try {
                if (currentUser) {
                    await setDoc(doc(db, 'users', currentUser.uid), {
                        online: false,
                        lastSeen: serverTimestamp()
                    }, { merge: true });
                }
                
                await signOut(auth);
            } catch (error) {
                console.error('Logout error:', error);
                hideLoading();
                showError('Failed to sign out. Please try again.');
            }
        }

        // User search functions
        async function searchUsers(searchTerm) {
            if (searchTerm.length < 2) {
                document.getElementById('search-results').classList.add('hidden');
                return;
            }

            try {
                const searchQuery = query(
                    collection(db, 'users'),
                    where('username', '>=', searchTerm.toLowerCase()),
                    where('username', '<=', searchTerm.toLowerCase() + '\uf8ff'),
                    limit(10)
                );

                const snapshot = await getDocs(searchQuery);
                const results = [];
                
                snapshot.forEach(doc => {
                    const userData = doc.data();
                    if (userData.uid !== currentUser.uid) {
                        results.push(userData);
                    }
                });

                displayUserSearchResults(results);
                
            } catch (error) {
                console.error('Search error:', error);
            }
        }

        function displayUserSearchResults(users) {
            const resultsContainer = document.getElementById('search-results-list');
            const searchResults = document.getElementById('search-results');
            
            if (users.length === 0) {
                resultsContainer.innerHTML = '<p class="text-gray-500 text-sm">No users found</p>';
            } else {
                resultsContainer.innerHTML = users.map(user => `
                    <div class="flex items-center space-x-3 p-3 rounded-lg hover:bg-gray-50 cursor-pointer chat-list-item"
                         onclick="startChat('${user.uid}', '${user.displayName}', '${user.username}', '${user.email}')">
                        <div class="relative">
                            <div class="profile-avatar">
                                ${user.displayName.charAt(0).toUpperCase()}
                            </div>
                            ${user.online ? '<div class="online-indicator"></div>' : ''}
                        </div>
                        <div class="flex-1 min-w-0">
                            <h4 class="font-medium text-gray-900 truncate">${user.displayName}</h4>
                            <p class="text-sm text-gray-500 truncate">@${user.username}</p>
                        </div>
                    </div>
                `).join('');
            }
            
            searchResults.classList.remove('hidden');
        }

        // Recent chats functions
        async function loadRecentChats() {
            if (!currentUser) return;
            
            try {
                const chatsQuery = query(
                    collection(db, 'chatMetadata'),
                    where('participants', 'array-contains', currentUser.uid),
                    orderBy('lastMessageTime', 'desc'),
                    limit(20)
                );
                
                if (recentChatsListener) {
                    recentChatsListener();
                }
                
                recentChatsListener = onSnapshot(chatsQuery, async (snapshot) => {
                    const chatList = document.getElementById('chat-list');
                    chatList.innerHTML = '';
                    
                    if (snapshot.empty) {
                        chatList.innerHTML = '<p class="text-gray-500 text-sm p-3">No recent chats. Search for users to start chatting!</p>';
                        return;
                    }
                    
                    const chats = [];
                    snapshot.forEach(doc => {
                        chats.push({ id: doc.id, ...doc.data() });
                    });
                    
                    for (const chat of chats) {
                        const otherUserId = chat.participants.find(id => id !== currentUser.uid);
                        if (!otherUserId) continue;
                        
                        const otherUserDoc = await getDoc(doc(db, 'users', otherUserId));
                        if (!otherUserDoc.exists()) continue;
                        
                        const otherUser = otherUserDoc.data();
                        
                        let lastMessagePreview = 'No messages yet';
                        if (chat.lastMessage) {
                            try {
                                lastMessagePreview = await bulletproofDecryptMessage(chat.lastMessage);
                                if (lastMessagePreview.length > 40) {
                                    lastMessagePreview = lastMessagePreview.substring(0, 40) + '...';
                                }
                            } catch (error) {
                                console.error('Error decrypting chat preview:', error);
                                lastMessagePreview = '💬 Recent message';
                            }
                        }
                        
                        const timeAgo = chat.lastMessageTime ? 
                            new Date(chat.lastMessageTime.toDate()).toLocaleTimeString([], {
                                hour: '2-digit',
                                minute: '2-digit'
                            }) : '';
                        
                        const chatElement = document.createElement('div');
                        chatElement.className = 'flex items-center space-x-3 p-3 rounded-lg hover:bg-gray-50 cursor-pointer chat-list-item';
                        chatElement.onclick = () => startChat(otherUser.uid, otherUser.displayName, otherUser.username, otherUser.email);
                        
                        chatElement.innerHTML = `
                            <div class="relative">
                                <div class="profile-avatar profile-avatar-lg">
                                    ${otherUser.displayName.charAt(0).toUpperCase()}
                                </div>
                                ${otherUser.online ? '<div class="online-indicator"></div>' : ''}
                            </div>
                            <div class="flex-1 min-w-0">
                                <div class="flex items-center justify-between">
                                    <h4 class="font-medium text-gray-900 truncate">${otherUser.displayName}</h4>
                                    <span class="text-xs text-gray-500">${timeAgo}</span>
                                </div>
                                <p class="text-sm text-gray-500 truncate">@${otherUser.username}</p>
                                <p class="text-sm text-gray-600 truncate mt-1">${lastMessagePreview}</p>
                            </div>
                        `;
                        
                        chatList.appendChild(chatElement);
                    }
                });
                
            } catch (error) {
                console.error('Error loading recent chats:', error);
            }
        }

        async function updateChatMetadata(otherUserId, lastMessage) {
            const chatId = generateChatId(currentUser.uid, otherUserId);
            
            try {
                await setDoc(doc(db, 'chatMetadata', chatId), {
                    participants: [currentUser.uid, otherUserId],
                    lastMessage: lastMessage,
                    lastMessageTime: serverTimestamp(),
                    lastMessageSender: currentUser.uid
                }, { merge: true });
            } catch (error) {
                console.error('Error updating chat metadata:', error);
            }
        }

        // Chat functions
        async function startChat(userId, displayName, username, email) {
            currentChatUser = { uid: userId, displayName, username, email };
            
            document.getElementById('search-results').classList.add('hidden');
            document.getElementById('search-users').value = '';
            
            document.getElementById('welcome-screen').classList.add('hidden');
            document.getElementById('chat-header').classList.remove('hidden');
            document.getElementById('messages-container').classList.remove('hidden');
            document.getElementById('message-input-container').classList.remove('hidden');
            
            document.getElementById('chat-user-name').textContent = displayName;
            document.getElementById('chat-user-avatar').textContent = displayName.charAt(0).toUpperCase();
            
            // Check if user is blocked and update UI accordingly
            const isBlocked = await checkIfUserBlocked(userId);
            const isBlockedByUser = await checkIfBlockedByUser(userId);
            
            // Update chat status
            const statusElement = document.getElementById('chat-user-status');
            if (isBlocked) {
                statusElement.textContent = 'Blocked';
                statusElement.style.color = '#dc2626';
            } else if (isBlockedByUser) {
                statusElement.textContent = 'You are blocked';
                statusElement.style.color = '#dc2626';
            } else {
                statusElement.textContent = 'Online';
                statusElement.style.color = '#6b7280';
            }
            
            // Disable message input if blocked by user
            const messageInput = document.getElementById('message-input');
            const messageForm = document.getElementById('message-form');
            if (isBlockedByUser) {
                messageInput.disabled = true;
                messageInput.placeholder = 'You cannot send messages to this user';
                messageForm.style.opacity = '0.5';
                messageForm.style.pointerEvents = 'none';
            } else {
                messageInput.disabled = false;
                messageInput.placeholder = 'Type your message...';
                messageForm.style.opacity = '1';
                messageForm.style.pointerEvents = 'auto';
            }
            
            // Handle mobile navigation
            if (isMobile()) {
                showMobileChat();
            }
            
            loadMessages(userId);
            loadPinnedMessages();
        }

        async function loadMessages(otherUserId) {
            if (messageListeners.has(otherUserId)) {
                messageListeners.get(otherUserId)();
                messageListeners.delete(otherUserId);
            }
            if (reactionListeners.has(otherUserId)) {
                reactionListeners.get(otherUserId)();
                reactionListeners.delete(otherUserId);
            }
            
            const chatId = generateChatId(currentUser.uid, otherUserId);
            
            // Load encryption key for this chat
            await loadKeyForCurrentChat();
            const messagesRef = collection(db, 'chats', chatId, 'messages');
            const reactionsRef = collection(db, 'chats', chatId, 'reactions');
            const q = query(messagesRef, orderBy('timestamp', 'desc'), limit(50));
            
            let reactionsData = {};
            
            const reactionUnsubscribe = onSnapshot(reactionsRef, (snapshot) => {
                reactionsData = {};
                snapshot.forEach(doc => {
                    const reaction = doc.data();
                    if (!reactionsData[reaction.messageId]) {
                        reactionsData[reaction.messageId] = {};
                    }
                    reactionsData[reaction.messageId][doc.id] = reaction;
                });
                
                Object.keys(reactionsData).forEach(messageId => {
                    const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                    if (messageElement) {
                        const reactionsContainer = messageElement.querySelector('.message-reactions');
                        if (reactionsContainer) {
                            renderReactions(reactionsData[messageId], messageId, chatId, reactionsContainer);
                        }
                    }
                });
            });
            
            const messageUnsubscribe = onSnapshot(q, async (snapshot) => {
                const messagesContainer = document.getElementById('messages-container');
                messagesContainer.innerHTML = '';
                
                const messages = [];
                snapshot.forEach(doc => {
                    messages.push({ id: doc.id, ...doc.data() });
                });
                
                messages.reverse();
                
                let lastMessageDate = null;
                
                for (let i = 0; i < messages.length; i++) {
                    const messageData = messages[i];
                    const messageDate = messageData.timestamp ? new Date(messageData.timestamp.toDate()) : new Date();
                    
                    // Skip messages deleted for this user
                    if (messageData.deletedForUsers && messageData.deletedForUsers.includes(currentUser.uid)) {
                        continue;
                    }
                    
                    if (!lastMessageDate || !isSameDay(lastMessageDate, messageDate)) {
                        const dateSeparator = document.createElement('div');
                        dateSeparator.className = 'date-separator';
                        dateSeparator.textContent = formatDateGroup(messageDate);
                        messagesContainer.appendChild(dateSeparator);
                        lastMessageDate = messageDate;
                    }
                    
                    const isMyMessage = messageData.senderId === currentUser.uid;
                    const timestamp = messageData.timestamp ? 
                        messageDate.toLocaleTimeString([], {
                            hour: '2-digit',
                            minute: '2-digit'
                        }) : 'Sending...';
                    
                    const messageContainer = document.createElement('div');
                    messageContainer.className = `message-container ${isMyMessage ? 'my-message-container' : 'other-message-container'} flex ${isMyMessage ? 'justify-end' : 'justify-start'}`;
                    messageContainer.setAttribute('data-message-id', messageData.id);
                    
                    const messageWrapper = document.createElement('div');
                    messageWrapper.className = 'relative';
                    
                    // Check if message is deleted for everyone
                    let messageContent = '';
                    let isDeleted = messageData.deleted && messageData.deletedForEveryone;
                    
                    if (isDeleted) {
                        messageContent = `
                            <div class="deleted-message-content">
                                <i class="fas fa-ban text-gray-400 mr-2"></i>
                                <span class="italic text-gray-500">This message was deleted</span>
                            </div>
                        `;
                    } else if (messageData.type === 'voice') {
                        // Handle voice messages
                        const voiceData = messageData.voiceData;
                        messageContent = `
                            <div class="message-content">
                                ${getForwardedHeader(messageData.forwarded, isMyMessage)}
                                ${getRepliedMessageHeader(messageData.replyTo, isMyMessage)}
                                <div class="voice-message ${isMyMessage ? 'my-voice' : ''}">
                                    <div class="flex items-center space-x-2 mb-2">
                                        <i class="fas fa-microphone text-sm opacity-70"></i>
                                        <span class="text-sm font-medium">Voice Message</span>
                                    </div>
                                    <audio controls class="w-full">
                                        <source src="${voiceData.url}" type="audio/webm">
                                        <source src="${voiceData.url}" type="audio/ogg">
                                        Your browser does not support the audio element.
                                    </audio>
                                    <div class="voice-duration text-right">
                                        ${formatVoiceDuration(voiceData.duration)}
                                    </div>
                                </div>
                            </div>
                        `;
                    } else if (messageData.type === 'file') {
                        // Handle file messages
                        const fileData = messageData.fileData;
                        if (fileData.type.startsWith('image/')) {
                            messageContent = `
                                <div class="message-content">
                                    ${getForwardedHeader(messageData.forwarded, isMyMessage)}
                                    ${getRepliedMessageHeader(messageData.replyTo, isMyMessage)}
                                    <div class="media-message" onclick="openLightbox('${fileData.url}')">
                                        <img src="${fileData.url}" alt="${fileData.name}" class="max-w-xs rounded-lg cursor-pointer" />
                                    </div>
                                </div>
                            `;
                        } else if (fileData.type.startsWith('video/')) {
                            messageContent = `
                                <div class="message-content">
                                    ${getForwardedHeader(messageData.forwarded, isMyMessage)}
                                    ${getRepliedMessageHeader(messageData.replyTo, isMyMessage)}
                                    <div class="media-message">
                                        <video controls class="max-w-xs rounded-lg">
                                            <source src="${fileData.url}" type="${fileData.type}">
                                            Your browser does not support the video tag.
                                        </video>
                                    </div>
                                </div>
                            `;
                        } else {
                            messageContent = `
                                <div class="message-content">
                                    ${getForwardedHeader(messageData.forwarded, isMyMessage)}
                                    ${getRepliedMessageHeader(messageData.replyTo, isMyMessage)}
                                    <div class="file-message">
                                        <a href="${fileData.url}" download="${fileData.name}" class="flex items-center space-x-2 p-2 bg-gray-100 rounded-lg hover:bg-gray-200 transition-colors">
                                            <i class="${getFileIcon(fileData.type)} text-lg"></i>
                                            <div>
                                                <p class="text-sm font-medium text-gray-800">${fileData.name}</p>
                                                <p class="text-xs text-gray-500">${formatFileSize(fileData.size)}</p>
                                            </div>
                                        </a>
                                    </div>
                                </div>
                            `;
                        }
                    } else {
                        // Handle text messages
                        const decryptedText = await bulletproofDecryptMessage(messageData);
                        
                        const textWithLinks = makeLinksClickable(decryptedText);
                        
                        messageContent = `
                            <div class="message-content">
                                ${getForwardedHeader(messageData.forwarded, isMyMessage)}
                                ${getRepliedMessageHeader(messageData.replyTo, isMyMessage)}
                                <p class="${isMyMessage ? 'text-white' : 'text-gray-700'}">${textWithLinks}</p>
                            </div>
                        `;
                    }
                    
                    const bubbleClass = isDeleted ? 'deleted-message' : '';
                    
                    messageWrapper.innerHTML = `
                        <div class="message-bubble ${isMyMessage ? 'my-message' : 'other-message'} ${bubbleClass} p-3 rounded-2xl shadow-sm">
                            
                            ${messageContent}
                            <p class="text-xs mt-2 ${isMyMessage ? 'text-white/70' : 'text-gray-500'}">
                                ${timestamp}
                                ${messageData.pinned ? '<i class="fas fa-thumbtack message-pin-indicator"></i>' : ''}
                            </p>
                        </div>
                        <div class="message-reactions"></div>
                    `;
                    
                    // Process link previews for text messages
                    if (!isDeleted && messageData.ciphertext) {
                        const decryptedText = await bulletproofDecryptMessage(messageData);
                        processMessageLinks(messageWrapper, decryptedText);
                    } else if (messageData.text && !isDeleted) {
                        processMessageLinks(messageWrapper, messageData.text);
                    }
                    
                    const messageActions = document.createElement('div');
                    messageActions.className = 'message-actions';
                    
                    // Add reaction button only if message is not deleted
                    if (!isDeleted) {
                        messageActions.appendChild(createReactionButton(messageWrapper, messageData.id, chatId));
                    }
                    
                    // Add long press / right click for message menu
                    let pressTimer;
                    messageWrapper.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        if (!isDeleted) {
                            showMessageMenu(messageWrapper, messageData.id, chatId, isMyMessage);
                        }
                    });
                    
                    messageWrapper.addEventListener('touchstart', (e) => {
                        pressTimer = setTimeout(() => {
                            if (!isDeleted) {
                                showMessageMenu(messageWrapper, messageData.id, chatId, isMyMessage);
                                if (navigator.vibrate) {
                                    navigator.vibrate(50);
                                }
                            }
                        }, 500);
                    });
                    
                    messageWrapper.addEventListener('touchend', () => {
                        clearTimeout(pressTimer);
                    });
                    
                    messageWrapper.addEventListener('touchmove', () => {
                        clearTimeout(pressTimer);
                    });
                    
                    messageWrapper.appendChild(messageActions);
                    messageContainer.appendChild(messageWrapper);
                    messagesContainer.appendChild(messageContainer);
                    
                    if (reactionsData[messageData.id]) {
                        const reactionsContainer = messageWrapper.querySelector('.message-reactions');
                        renderReactions(reactionsData[messageData.id], messageData.id, chatId, reactionsContainer);
                    }
                }
                
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            });
            
            messageListeners.set(otherUserId, messageUnsubscribe);
            reactionListeners.set(otherUserId, reactionUnsubscribe);
        }

        async function sendMessage(event) {
            event.preventDefault();
            
            // Prevent sending multiple messages at once
            if (isSendingMessage) {
                return;
            }
            
            const messageInput = document.getElementById('message-input');
            const sendButton = document.querySelector('#message-form button[type="submit"]');
            const messageText = messageInput.value.trim();
            
            if (!messageText && !window.pendingFile) {
                return;
            }
            
            if (!currentChatUser) {
                showError('Please select a user to chat with');
                return;
            }
            
            // Check if user is blocked by the recipient
            const isBlockedByRecipient = await checkIfBlockedByUser(currentChatUser.uid);
            if (isBlockedByRecipient) {
                showError('You cannot send messages to this user');
                messageInput.value = '';
                if (window.pendingFile) {
                    clearFilePreview();
                }
                return;
            }
            
            try {
                // Set sending state
                isSendingMessage = true;
                messageInput.disabled = true;
                sendButton.disabled = true;
                sendButton.style.opacity = '0.5';
                sendButton.style.cursor = 'not-allowed';
                const chatId = generateChatId(currentUser.uid, currentChatUser.uid);
                
                // Ensure encryption key is loaded for this chat
                if (!e2eKey) {
                    await loadKeyForCurrentChat();
                }
                
                let messageData = {
                    senderId: currentUser.uid,
                    senderName: currentUser.displayName,
                    senderEmail: currentUser.email,
                    recipientId: currentChatUser.uid,
                    timestamp: serverTimestamp()
                };

                // Handle reply if replying to a message
                if (currentReplyingTo) {
                    messageData.replyTo = {
                        messageId: currentReplyingTo.id,
                        senderId: currentReplyingTo.senderId,
                        senderName: currentReplyingTo.senderId === currentUser.uid ? 'You' : (currentChatUser.displayName || currentChatUser.username || 'Unknown User'),
                        timestamp: currentReplyingTo.timestamp
                    };

                    // Store the replied message content for preview
                    if (currentReplyingTo.text || currentReplyingTo.ciphertext) {
                        if (currentReplyingTo.ciphertext) {
                            try {
                                const decrypted = await safeDecryptMessage(currentReplyingTo);
                                messageData.replyTo.content = decrypted;
                                messageData.replyTo.type = 'text';
                            } catch (error) {
                                messageData.replyTo.content = 'Encrypted message';
                                messageData.replyTo.type = 'text';
                            }
                        } else {
                            messageData.replyTo.content = currentReplyingTo.text;
                            messageData.replyTo.type = 'text';
                        }
                    } else if (currentReplyingTo.type === 'image' || currentReplyingTo.imageUrl) {
                        messageData.replyTo.content = 'Image';
                        messageData.replyTo.type = 'image';
                    } else if (currentReplyingTo.type === 'file' || currentReplyingTo.fileUrl) {
                        messageData.replyTo.content = currentReplyingTo.fileName || 'File';
                        messageData.replyTo.type = 'file';
                    } else if (currentReplyingTo.type === 'voice' || currentReplyingTo.voiceUrl) {
                        messageData.replyTo.content = 'Voice message';
                        messageData.replyTo.type = 'voice';
                    }
                }

                // Handle file upload
                if (window.pendingFile) {
                    const fileData = await uploadFile(window.pendingFile, chatId);
                    if (!fileData) return; // Upload failed
                    
                    messageData.type = 'file';
                    messageData.fileData = fileData;
                    messageData.ciphertext = [];
                    messageData.iv = [];
                    
                    // Clear pending file
                    window.pendingFile = null;
                } else {
                    // Handle text message
                    const { ciphertext, iv } = await encryptMessage(messageText);
                    messageData.type = 'text';
                    messageData.ciphertext = ciphertext;
                    messageData.iv = iv;
                }
                
                await addDoc(collection(db, 'chats', chatId, 'messages'), messageData);
                
                // Update chat metadata
                if (messageData.type === 'text') {
                    await updateChatMetadata(currentChatUser.uid, { ciphertext: messageData.ciphertext, iv: messageData.iv });
                } else {
                    // For files, store a placeholder message for recent chats
                    const placeholderText = `📎 ${messageData.fileData.name}`;
                    const { ciphertext, iv } = await encryptMessage(placeholderText);
                    await updateChatMetadata(currentChatUser.uid, { ciphertext, iv });
                }
                
                messageInput.value = '';
                messageInput.style.height = '44px'; // Reset textarea height
                
                // Clear reply preview if replying
                if (currentReplyingTo) {
                    clearReplyPreview();
                }
                
            } catch (error) {
                console.error('Error sending message:', error);
                showError('Failed to send message');
            } finally {
                // Re-enable inputs
                isSendingMessage = false;
                messageInput.disabled = false;
                sendButton.disabled = false;
                sendButton.style.opacity = '1';
                sendButton.style.cursor = 'pointer';
                messageInput.focus();
            }
        }

        // Event listeners
        document.getElementById('signup-form-element').addEventListener('submit', handleSignup);
        document.getElementById('login-form-element').addEventListener('submit', handleLogin);
        document.getElementById('logout-btn').addEventListener('click', handleLogout);
        document.getElementById('message-form').addEventListener('submit', sendMessage);
        document.getElementById('close-error').addEventListener('click', hideError);
        
        // Multiline message input support
        (function() {
            const messageInputElement = document.getElementById('message-input');
            
            // Auto-resize textarea as content grows
            messageInputElement.addEventListener('input', function() {
                this.style.height = '44px'; // Reset to minimum
                const newHeight = Math.min(this.scrollHeight, 150); // Max 150px
                this.style.height = newHeight + 'px';
            });
            
            // Handle Enter vs Shift+Enter
            messageInputElement.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    // Enter without Shift - send message
                    e.preventDefault();
                    const form = document.getElementById('message-form');
                    form.dispatchEvent(new Event('submit', { cancelable: true }));
                }
                // Shift+Enter - allow default behavior (new line)
            });
        })();
        
        // Dark mode toggle listener
        document.getElementById('dark-mode-toggle').addEventListener('click', toggleDarkMode);
        
        // User options menu listeners
        document.getElementById('chat-options-btn').addEventListener('click', showUserOptionsMenu);
        document.getElementById('mobile-menu-btn').addEventListener('click', showUserOptionsMenu);
        
        // Message search listeners
        document.getElementById('message-search-btn').addEventListener('click', openMessageSearch);
        
        // Search input listeners
        const searchInput = document.getElementById('message-search-input');
        const searchClearBtn = document.querySelector('.message-search-clear-btn');
        
        searchInput.addEventListener('input', (e) => {
            const value = e.target.value;
            if (value.trim()) {
                searchClearBtn.classList.add('visible');
                // Debounce search
                clearTimeout(searchInput.searchTimeout);
                searchInput.searchTimeout = setTimeout(() => {
                    searchMessages(value);
                }, 300);
            } else {
                searchClearBtn.classList.remove('visible');
                clearMessageSearch();
            }
        });
        
        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeMessageSearch();
            }
        });
        
        // File upload functionality
        const fileInput = document.getElementById('file-input');
        const fileButton = document.getElementById('file-upload-btn');
        
        fileButton.addEventListener('click', () => {
            fileInput.click();
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleFileSelect(file);
            }
        });
        
        // Drag and drop functionality
        const messageInput = document.getElementById('message-input');
        
        messageInput.addEventListener('dragover', (e) => {
            e.preventDefault();
            messageInput.classList.add('drag-over');
        });
        
        messageInput.addEventListener('dragleave', (e) => {
            e.preventDefault();
            messageInput.classList.remove('drag-over');
        });
        
        messageInput.addEventListener('drop', (e) => {
            e.preventDefault();
            messageInput.classList.remove('drag-over');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileSelect(files[0]);
            }
        });
        
        // Handle file selection
        function handleFileSelect(file) {
            if (file.size > 5 * 1024 * 1024) { // 5MB limit
                showError('File size must be less than 5MB');
                return;
            }
            
            window.pendingFile = file;
            showFilePreview(file);
        }
        
        function showFilePreview(file) {
            const filePreview = document.getElementById('file-preview');
            filePreview.style.display = 'block';
            
            const fileName = document.getElementById('file-name');
            const fileSize = document.getElementById('file-size');
            const fileIcon = document.getElementById('file-icon');
            const removeFileBtn = document.getElementById('remove-file');
            
            fileName.textContent = file.name;
            fileSize.textContent = formatFileSize(file.size);
            fileIcon.className = getFileIcon(file.type);
            
            removeFileBtn.onclick = () => {
                window.pendingFile = null;
                filePreview.style.display = 'none';
                fileInput.value = '';
            };
        }
        
        document.getElementById('show-signup').addEventListener('click', () => {
            document.getElementById('login-form').classList.add('hidden');
            document.getElementById('signup-form').classList.remove('hidden');
        });

        document.getElementById('show-login').addEventListener('click', () => {
            document.getElementById('signup-form').classList.add('hidden');
            document.getElementById('login-form').classList.remove('hidden');
        });

        let searchTimeout;
        document.getElementById('search-users').addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                searchUsers(e.target.value.trim());
            }, 300);
        });

        window.startChat = startChat;

        // Mobile functionality
        function isMobile() {
            return window.innerWidth <= 768;
        }
        
        function showMobileChat() {
            if (isMobile()) {
                document.getElementById('chat-sidebar').classList.add('hidden-mobile');
            }
        }
        
        function showMobileSidebar() {
            if (isMobile()) {
                document.getElementById('chat-sidebar').classList.remove('hidden-mobile');
            }
        }
        
        // Mobile back button
        document.getElementById('mobile-back-btn').addEventListener('click', () => {
            showMobileSidebar();
            // Hide chat area on mobile
            document.getElementById('chat-header').classList.add('hidden');
            document.getElementById('messages-container').classList.add('hidden');
            document.getElementById('message-input-container').classList.add('hidden');
            document.getElementById('welcome-screen').classList.remove('hidden');
            currentChatUser = null;
        });
        
        // Mobile menu button (for future features)
        document.getElementById('mobile-menu-btn').addEventListener('click', () => {
            // Future: Show chat options menu
            console.log('Mobile menu clicked');
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (!isMobile()) {
                // Show sidebar on desktop
                document.getElementById('chat-sidebar').classList.remove('hidden-mobile');
            }
        });
        
        // Touch-friendly interactions
        let touchStartY = 0;
        let touchStartTime = 0;
        
        // Improved touch handling for message containers
        document.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
            touchStartTime = Date.now();
        });
        
        document.addEventListener('touchend', (e) => {
            const touchEndY = e.changedTouches[0].clientY;
            const touchDuration = Date.now() - touchStartTime;
            const touchDistance = Math.abs(touchEndY - touchStartY);
            
            // If it's a short touch with minimal movement, treat as tap
            if (touchDuration < 300 && touchDistance < 10) {
                // Handle as click
                return true;
            }
        });
        
        // Prevent double-tap zoom on mobile
        let lastTouchEnd = 0;
        document.addEventListener('touchend', (e) => {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                e.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        // Mobile-specific input handling
        // Prevent zoom on input focus (iOS)
        messageInput.addEventListener('touchstart', () => {
            if (isMobile()) {
                messageInput.style.fontSize = '16px';
            }
        });
        
        // Scroll to input when keyboard appears
        messageInput.addEventListener('focus', () => {
            if (isMobile()) {
                setTimeout(() => {
                    messageInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 300);
            }
        });
        
        // Auto-hide mobile keyboard when scrolling messages
        if (isMobile()) {
            let messagesContainer = document.getElementById('messages-container');
            let scrollTimeout;
            
            messagesContainer.addEventListener('touchstart', () => {
                if (document.activeElement === messageInput) {
                    messageInput.blur();
                }
            });
            
            // Handle viewport height changes (keyboard appearance)
            let initialViewportHeight = window.innerHeight;
            window.addEventListener('resize', () => {
                const currentHeight = window.innerHeight;
                const heightDifference = initialViewportHeight - currentHeight;
                
                // If height decreased significantly, keyboard is probably open
                if (heightDifference > 150) {
                    document.body.style.paddingBottom = `${heightDifference}px`;
                } else {
                    document.body.style.paddingBottom = '0px';
                }
            });
        }
        
        // Add swipe gestures for mobile navigation
        let swipeStartX = 0;
        let swipeStartY = 0;
        let swipeStarted = false;
        
        document.addEventListener('touchstart', (e) => {
            // Only handle swipes, not other touch interactions
            if (e.touches.length === 1) {
                swipeStartX = e.touches[0].clientX;
                swipeStartY = e.touches[0].clientY;
                swipeStarted = true;
            }
        });
        
        document.addEventListener('touchmove', (e) => {
            if (!swipeStarted || !isMobile() || e.touches.length !== 1) return;
            
            const currentX = e.touches[0].clientX;
            const currentY = e.touches[0].clientY;
            const deltaX = currentX - swipeStartX;
            const deltaY = currentY - swipeStartY;
            
            // Check if it's more horizontal than vertical movement
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
                // Swipe right to go back to sidebar (when in chat view)
                if (deltaX > 0 && currentChatUser && e.target.closest('.chat-main')) {
                    e.preventDefault();
                    showMobileSidebar();
                    document.getElementById('chat-header').classList.add('hidden');
                    document.getElementById('messages-container').classList.add('hidden');
                    document.getElementById('message-input-container').classList.add('hidden');
                    document.getElementById('welcome-screen').classList.remove('hidden');
                    currentChatUser = null;
                    swipeStarted = false;
                }
            }
        });
        
        document.addEventListener('touchend', () => {
            swipeStarted = false;
        });
        
        // Accessibility improvements
        // Add ARIA labels for better screen reader support
        if (document.getElementById('file-upload-btn')) {
            document.getElementById('file-upload-btn').setAttribute('aria-label', 'Upload file');
        }
        
        // Add focus indicators for keyboard navigation
        const style = document.createElement('style');
        style.textContent = `
            @media (max-width: 768px) {
                *:focus {
                    outline: 2px solid #3b82f6 !important;
                    outline-offset: 2px !important;
                }
                
                .message-bubble:focus {
                    box-shadow: 0 0 0 2px #3b82f6;
                }
            }
        `;
        document.head.appendChild(style);

        // Initialize dark mode
        initializeDarkMode();

        // Authentication state observer
        onAuthStateChanged(auth, async (user) => {
            try {
                if (user) {
                    // User is signed in
                    currentUser = user;
                    
                    // Update loading message
                    const loadingText = document.querySelector('#loading-overlay p');
                    if (loadingText) {
                        loadingText.textContent = 'Loading your conversations...';
                    }
                    
                    // Set user as online
                    await setDoc(doc(db, 'users', user.uid), {
                        online: true,
                        lastSeen: serverTimestamp()
                    }, { merge: true });
                    
                    // Get user data
                    const userDoc = await getDoc(doc(db, 'users', user.uid));
                    const userData = userDoc.data();
                    
                    // Update UI with user info
                    document.getElementById('current-user-name').textContent = userData.displayName;
                    document.getElementById('current-user-email').textContent = userData.email;
                    
                    // Initialize encryption and load data
                    await generateE2EKey();
                    await loadRecentChats();
                    
                    // Hide loading and show chat interface
                    document.getElementById('loading-overlay').classList.add('hidden');
                    document.getElementById('auth-container').classList.add('hidden');
                    document.getElementById('chat-interface').classList.remove('hidden');
                    
                } else {
                    // User is signed out
                    currentUser = null;
                    currentChatUser = null;
                    
                    // Clean up listeners
                    messageListeners.forEach(unsubscribe => unsubscribe());
                    messageListeners.clear();
                    
                    reactionListeners.forEach(unsubscribe => unsubscribe());
                    reactionListeners.clear();
                    
                    if (recentChatsListener) {
                        recentChatsListener();
                        recentChatsListener = null;
                    }
                    
                    // Hide loading and chat interface, show auth
                    document.getElementById('loading-overlay').classList.add('hidden');
                    document.getElementById('chat-interface').classList.add('hidden');
                    document.getElementById('auth-container').classList.remove('hidden');
                }
            } catch (error) {
                console.error('Auth state change error:', error);
                
                // On error, hide loading and show auth
                document.getElementById('loading-overlay').classList.add('hidden');
                document.getElementById('chat-interface').classList.add('hidden');
                document.getElementById('auth-container').classList.remove('hidden');
                
                showError('Failed to initialize. Please try again.');
            }
        });

        // Register Service Worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', async () => {
                try {
                    const registration = await navigator.serviceWorker.register('/static/sw.js');
                    console.log('ServiceWorker registration successful:', registration.scope);
                    
                    // Check for updates
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                // New content available, show update notification
                                showSuccess('New version available! Refresh to update.');
                            }
                        });
                    });
                } catch (error) {
                    console.log('ServiceWorker registration failed:', error);
                }
            });
        }

        // PWA Install prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent Chrome 67 and earlier from automatically showing the prompt
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            
            // Show install button or banner
            showInstallPrompt();
        });

        function showInstallPrompt() {
            // Create install button if it doesn't exist
            if (!document.getElementById('install-app-btn')) {
                const installBtn = document.createElement('button');
                installBtn.id = 'install-app-btn';
                installBtn.innerHTML = '<i class="fas fa-download mr-2"></i>Install App';
                installBtn.className = 'fixed bottom-4 right-4 bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg shadow-lg transition-all duration-300 z-50';
                installBtn.addEventListener('click', installApp);
                document.body.appendChild(installBtn);
                
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    if (installBtn.parentNode) {
                        installBtn.remove();
                    }
                }, 10000);
            }
        }

        async function installApp() {
            if (deferredPrompt) {
                // Show the prompt
                deferredPrompt.prompt();
                // Wait for the user to respond to the prompt
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`User response to the install prompt: ${outcome}`);
                // Clear the deferredPrompt
                deferredPrompt = null;
                // Remove install button
                const installBtn = document.getElementById('install-app-btn');
                if (installBtn) {
                    installBtn.remove();
                }
            }
        }

        // Handle app installation
        window.addEventListener('appinstalled', (evt) => {
            console.log('Enlock Chat app was installed.');
            showSuccess('Enlock Chat installed successfully!');
        });
        // Global error handler for unhandled promise rejections
        window.addEventListener('unhandledrejection', (event) => {
            if (event.reason && event.reason.toString().includes('DOMException')) {
                console.error('Unhandled decryption error:', event.reason);
                // Prevent the error from showing in console
                event.preventDefault();
                
                // Show user-friendly message
                showError('A message could not be decrypted. This may be due to encryption key issues. Try refreshing the page.');
            }
        });

        // Debug and troubleshooting functions
        window.debugEnlockChat = {
            // Nuclear option - complete reset
            completeReset: async () => {
                try {
                    // Clear all encryption data
                    localStorage.removeItem('enlockChatKey');
                    localStorage.removeItem('darkMode');
                    
                    // Reset global variables
                    e2eKey = null;
                    currentUser = null;
                    currentChatUser = null;
                    
                    // Clear Firebase auth
                    if (auth && auth.currentUser) {
                        await signOut(auth);
                    }
                    
                    // Reload page
                    window.location.reload();
                } catch (error) {
                    console.error('Reset failed:', error);
                    window.location.reload();
                }
            },
            
            clearEncryptionKey: async () => {
                await clearStoredKey();
                await generateE2EKey();
                showSuccess("Encryption key reset. App should work better now.");
            },
            
            checkEncryptionStatus: () => {
                console.log("Encryption Status:", {
                    hasKey: !!e2eKey,
                    cryptoAvailable: !!(window.crypto && window.crypto.subtle),
                    keyInStorage: !!localStorage.getItem('enlockChatKey'),
                    algorithm: algo,
                    currentUser: !!currentUser
                });
            },
            
            testDecryption: async (messageData) => {
                try {
                    const result = await bulletproofDecryptMessage(messageData);
                    console.log("Test decryption result:", result);
                    return result;
                } catch (error) {
                    console.error("Test decryption failed:", error);
                    return error.message;
                }
            }
        };

        // Make safe decryption available globally
        
    </script>
</body>
</html>

